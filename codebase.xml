This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-18T03:23:18.602Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

- Line numbers have been added to the beginning of each line.
</notes>

<additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
.gitignore
.metadata
analysis_options.yaml
android/.gitignore
android/app/app.properties
android/app/build.gradle
android/app/proguard-rules.pro
android/app/src/debug/AndroidManifest.xml
android/app/src/main/AndroidManifest.xml
android/app/src/main/java/io/flutter/plugins/GeneratedPluginRegistrant.java
android/app/src/main/kotlin/com/example/fftcg_companion_app/MainActivity.kt
android/app/src/main/kotlin/com/mrw1986/fftcg_companion_app/MainActivity.kt
android/app/src/main/res/drawable-v21/launch_background.xml
android/app/src/main/res/drawable/launch_background.xml
android/app/src/main/res/values-night/styles.xml
android/app/src/main/res/values/styles.xml
android/app/src/main/res/xml/backup_rules.xml
android/app/src/main/res/xml/network_security_config.xml
android/app/src/profile/AndroidManifest.xml
android/build.gradle
android/gradle.properties
android/gradle/wrapper/gradle-wrapper.properties
android/settings.gradle
firebase.json
flutter_launcher_icons_card.yaml
flutter_launcher_icons.yaml
lib/core/logging/logger_service.dart
lib/core/models/sync_status.dart
lib/core/presentation/widgets/app_drawer.dart
lib/core/providers/app_providers.dart
lib/core/services/connectivity_service.dart
lib/core/services/hive_service.dart
lib/core/services/sync_service.dart
lib/core/theme/app_theme.dart
lib/features/auth/enums/auth_status.dart
lib/features/auth/models/auth_exception.dart
lib/features/auth/presentation/auth_wrapper.dart
lib/features/auth/presentation/screens/account_linking_screen.dart
lib/features/auth/presentation/screens/login_screen.dart
lib/features/auth/presentation/screens/registration_screen.dart
lib/features/auth/presentation/widgets/account_exists_dialog.dart
lib/features/auth/presentation/widgets/auth_button.dart
lib/features/auth/presentation/widgets/auth_error_widget.dart
lib/features/auth/presentation/widgets/auth_text_field.dart
lib/features/auth/providers/auth_notifier.dart
lib/features/auth/providers/auth_providers.dart
lib/features/auth/providers/auth_state.dart
lib/features/auth/repositories/auth_repository.dart
lib/features/auth/services/auth_service.dart
lib/features/cards/models/card_extended_data.dart
lib/features/cards/models/card_filter_options.dart
lib/features/cards/models/card_image_metadata.dart
lib/features/cards/models/fftcg_card.dart
lib/features/cards/presentation/screens/card_detail_screen.dart
lib/features/cards/presentation/screens/cards_screen.dart
lib/features/cards/presentation/widgets/card_grid_item.dart
lib/features/cards/presentation/widgets/card_list_item.dart
lib/features/cards/presentation/widgets/filter_bottom_sheet.dart
lib/features/cards/presentation/widgets/search_bar_widget.dart
lib/features/cards/presentation/widgets/sort_menu_button.dart
lib/features/cards/providers/card_notifier.dart
lib/features/cards/providers/card_providers.dart
lib/features/cards/providers/card_state.dart
lib/features/cards/repositories/card_repository.dart
lib/features/cards/services/card_cache_service.dart
lib/features/collection/presentation/screens/collection_screen.dart
lib/features/decks/presentation/screens/decks_screen.dart
lib/features/profile/models/collection_stats.dart
lib/features/profile/models/deck_stats.dart
lib/features/profile/models/user_stats.dart
lib/features/profile/presentation/screens/profile_screen.dart
lib/features/profile/presentation/widgets/collection_stats.dart
lib/features/profile/presentation/widgets/deck_stats.dart
lib/features/profile/presentation/widgets/profile_header.dart
lib/features/profile/providers/user_stats_provider.dart
lib/features/scanner/presentation/screens/scanner_screen.dart
lib/features/settings/presentation/screens/logs_viewer_screen.dart
lib/features/settings/presentation/screens/offline_management_screen.dart
lib/features/settings/presentation/screens/settings_screen.dart
lib/features/settings/presentation/widgets/color_picker.dart
lib/features/settings/presentation/widgets/offline_storage_info.dart
lib/features/settings/presentation/widgets/settings_switch_tile.dart
lib/features/settings/presentation/widgets/sync_action_card.dart
lib/features/settings/presentation/widgets/sync_progress_indicator.dart
lib/features/settings/presentation/widgets/sync_status_card.dart
lib/features/settings/presentation/widgets/theme_selector.dart
lib/features/settings/providers/settings_providers.dart
lib/main.dart
lib/models/user_model.dart
lib/services/firebase_service.dart
pubspec.yaml
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path=".gitignore">
  1: # Created by https://www.toptal.com/developers/gitignore/api/flutter,firebase,android,ios
  2: # Edit at https://www.toptal.com/developers/gitignore?templates=flutter,firebase,android,ios
  3: 
  4: ### Android ###
  5: # Built application files
  6: *.apk
  7: *.aab
  8: 
  9: # Files for the ART/Dalvik VM
 10: *.dex
 11: 
 12: # Java class files
 13: *.class
 14: 
 15: # Generated files
 16: bin/
 17: gen/
 18: out/
 19: codebase_export.txt
 20: 
 21: # Gradle files
 22: .gradle/
 23: build/
 24: 
 25: # Proguard folder generated by Eclipse
 26: proguard/
 27: 
 28: # Log Files
 29: *.log
 30: 
 31: # Android Studio Navigation editor temp files
 32: .navigation/
 33: 
 34: # Android Studio captures folder
 35: captures/
 36: 
 37: # IntelliJ
 38: *.iml
 39: .idea/workspace.xml
 40: .idea/tasks.xml
 41: .idea/gradle.xml
 42: .idea/assetWizardSettings.xml
 43: 
 44: # Keystore files
 45: *.jks
 46: *.keystore
 47: 
 48: # Google Services (e.g. APIs or Firebase)
 49: # google-services.json
 50: 
 51: # Android Patchers
 52: *.jardiff
 53: 
 54: # Personal preferences
 55: .idea/caches/build_file_checksums.ser
 56: 
 57: ### Flutter ###
 58: # Flutter/Dart/Pub related
 59: .dart_tool/
 60: .flutter-plugins
 61: .flutter-plugins-dependencies
 62: .packages
 63: .pub-cache/
 64: .pub/
 65: build/
 66: ios/*
 67: linux/*
 68: macos/*
 69: windows/*
 70: pubspec.lock
 71: README.md
 72: repomix.config.json
 73: web/index.html
 74: web/manifest.json
 75: export_codebase.ps1
 76: 
 77: # Freezed generated files
 78: *.freezed.dart
 79: *.g.dart
 80: 
 81: # Code generation
 82: *.mocks.dart
 83: *.config.dart
 84: *.gr.dart
 85: *.gen.dart
 86: 
 87: ### Firebase ###
 88: # Exclude specific Firebase service configuration files
 89: google-services.json
 90: GoogleService-Info.plist
 91: lib/firebase_options.dart
 92: */firebase_options.dart
 93: codebase.xml
 94: 
 95: 
 96: # Exclude local emulator databases
 97: /firestore_emulator_data/
 98: 
 99: ### iOS ###
100: # Xcode
101: #
102: # gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore & Swift.gitignore
103: 
104: ## User settings
105: xcuserdata/
106: 
107: ## compatibility with Xcode 8 and earlier (ignoring not required starting Xcode 9)
108: *.xcscmblueprint
109: *.xccheckout
110: 
111: ## compatibility with Xcode 3 and earlier (ignoring not required starting Xcode 4)
112: DerivedData/
113: *.moved-aside
114: *.pbxuser
115: !default.pbxuser
116: *.mode1v3
117: !default.mode1v3
118: *.mode2v3
119: !default.mode2v3
120: *.perspectivev3
121: !default.perspectivev3
122: 
123: ## Obj-C/Swift specific
124: *.hmap
125: *.ipa
126: *.dSYM.zip
127: *.dSYM
128: 
129: ## Playgrounds
130: timeline.xctimeline
131: playground.xcworkspace
132: 
133: # Swift Package Manager
134: #
135: # Add this line if you want to avoid checking in source code from Swift Package Manager dependencies.
136: # Packages/
137: # Package.pins
138: # Package.resolved
139: # *.xcodeproj
140: #
141: # Xcode automatically generates this directory. It contains temporary files and directories, including system and user caches.
142: # Users are encouraged to periodically delete this directory to reclaim disk space, and the contents of the directory can be safely deleted.
143: # This directory and its contents should not be checked into source code control.
144: xcuserdata
145: 
146: # CocoaPods
147: #
148: # We recommend against adding the Pods directory to your .gitignore. However
149: # you should judge for yourself, the pros and cons are mentioned at:
150: # https://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control
151: #
152: # Pods/
153: 
154: # Carthage
155: #
156: # Add this line if you want to avoid checking in source code from Carthage dependencies.
157: # Carthage/Checkouts
158: 
159: Carthage/Build
160: 
161: .DS_Store
162: 
163: # fastlane
164: fastlane/report.xml
165: fastlane/Preview.html
166: fastlane/screenshots
167: fastlane/test_output
168: 
169: # Local schemes - Xcode
170: *.xcscheme
171: 
172: # VSCode settings
173: .vscode/
174: 
175: # Flutter/Dart specific
176: *.inject.summary
177: *.inject.dart
178: *.reflectable.dart
179: 
180: # Local development
181: .env
182: .env.local
183: *.env.json
184: 
185: # IDE
186: *.ipr
187: *.iws
188: .idea/
</file>

<file path=".metadata">
 1: # This file tracks properties of this Flutter project.
 2: # Used by Flutter tool to assess capabilities and perform upgrades etc.
 3: #
 4: # This file should be version controlled and should not be manually edited.
 5: 
 6: version:
 7:   revision: "dec2ee5c1f98f8e84a7d5380c05eb8a3d0a81668"
 8:   channel: "stable"
 9: 
10: project_type: app
11: 
12: # Tracks metadata for the flutter migrate command
13: migration:
14:   platforms:
15:     - platform: root
16:       create_revision: dec2ee5c1f98f8e84a7d5380c05eb8a3d0a81668
17:       base_revision: dec2ee5c1f98f8e84a7d5380c05eb8a3d0a81668
18:     - platform: android
19:       create_revision: dec2ee5c1f98f8e84a7d5380c05eb8a3d0a81668
20:       base_revision: dec2ee5c1f98f8e84a7d5380c05eb8a3d0a81668
21:     - platform: ios
22:       create_revision: dec2ee5c1f98f8e84a7d5380c05eb8a3d0a81668
23:       base_revision: dec2ee5c1f98f8e84a7d5380c05eb8a3d0a81668
24:     - platform: linux
25:       create_revision: dec2ee5c1f98f8e84a7d5380c05eb8a3d0a81668
26:       base_revision: dec2ee5c1f98f8e84a7d5380c05eb8a3d0a81668
27:     - platform: macos
28:       create_revision: dec2ee5c1f98f8e84a7d5380c05eb8a3d0a81668
29:       base_revision: dec2ee5c1f98f8e84a7d5380c05eb8a3d0a81668
30:     - platform: web
31:       create_revision: dec2ee5c1f98f8e84a7d5380c05eb8a3d0a81668
32:       base_revision: dec2ee5c1f98f8e84a7d5380c05eb8a3d0a81668
33:     - platform: windows
34:       create_revision: dec2ee5c1f98f8e84a7d5380c05eb8a3d0a81668
35:       base_revision: dec2ee5c1f98f8e84a7d5380c05eb8a3d0a81668
36: 
37:   # User provided section
38: 
39:   # List of Local paths (relative to this file) that should be
40:   # ignored by the migrate tool.
41:   #
42:   # Files that are not part of the templates will be ignored by default.
43:   unmanaged_files:
44:     - 'lib/main.dart'
45:     - 'ios/Runner.xcodeproj/project.pbxproj'
</file>

<file path="analysis_options.yaml">
 1: # This file configures the analyzer, which statically analyzes Dart code to
 2: # check for errors, warnings, and lints.
 3: #
 4: # The issues identified by the analyzer are surfaced in the UI of Dart-enabled
 5: # IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
 6: # invoked from the command line by running `flutter analyze`.
 7: 
 8: # The following line activates a set of recommended lints for Flutter apps,
 9: # packages, and plugins designed to encourage good coding practices.
10: include: package:flutter_lints/flutter.yaml
11: 
12: linter:
13:   # The lint rules applied to this project can be customized in the
14:   # section below to disable rules from the `package:flutter_lints/flutter.yaml`
15:   # included above or to enable additional rules. A list of all available lints
16:   # and their documentation is published at https://dart.dev/lints.
17:   #
18:   # Instead of disabling a lint rule for the entire project in the
19:   # section below, it can also be suppressed for a single line of code
20:   # or a specific dart file by using the `// ignore: name_of_lint` and
21:   # `// ignore_for_file: name_of_lint` syntax on the line or in the file
22:   # producing the lint.
23:   rules:
24:     # avoid_print: false  # Uncomment to disable the `avoid_print` rule
25:     # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule
26: 
27: # Additional information about this file can be found at
28: # https://dart.dev/guides/language/analysis-options
</file>

<file path="android/.gitignore">
 1: gradle-wrapper.jar
 2: /.gradle
 3: /captures/
 4: /gradlew
 5: /gradlew.bat
 6: /local.properties
 7: GeneratedPluginRegistrant.java
 8: 
 9: # Remember to never publicly share your keystore.
10: # See https://flutter.dev/to/reference-keystore
11: key.properties
12: **/*.keystore
13: **/*.jks
</file>

<file path="android/app/app.properties">
1: appAuthRedirectScheme=com.mrw1986.fftcg_companion_app
</file>

<file path="android/app/build.gradle">
 1: plugins {
 2:     id "com.android.application"
 3:     id "kotlin-android"
 4:     id "dev.flutter.flutter-gradle-plugin"
 5:     id "com.google.gms.google-services"
 6:     id "com.google.firebase.crashlytics"
 7: }
 8: 
 9: def flutterVersionCode = project.hasProperty('flutter.versionCode') ? project.getProperty('flutter.versionCode') : '1'
10: def flutterVersionName = project.hasProperty('flutter.versionName') ? project.getProperty('flutter.versionName') : '1.0'
11: 
12: android {
13:     namespace "com.mrw1986.fftcg_companion_app"
14:     compileSdkVersion flutter.compileSdkVersion
15:     ndkVersion flutter.ndkVersion
16: 
17:     compileOptions {
18:         sourceCompatibility JavaVersion.VERSION_1_8
19:         targetCompatibility JavaVersion.VERSION_1_8
20:     }
21: 
22:     kotlinOptions {
23:         jvmTarget = '1.8'
24:     }
25: 
26:     sourceSets {
27:         main.java.srcDirs += 'src/main/kotlin'
28:     }
29: 
30:     defaultConfig {
31:     applicationId "com.mrw1986.fftcg_companion_app"
32:     minSdkVersion 23  // Changed from 21 to 23
33:     targetSdkVersion 34
34:     versionCode flutterVersionCode.toInteger()
35:     versionName flutterVersionName
36:     multiDexEnabled true
37:     
38:     manifestPlaceholders = [
39:         'applicationName': "io.flutter.app.FlutterApplication",
40:         'appAuthRedirectScheme': 'com.mrw1986.fftcg_companion_app'
41:     ]
42: }
43: 
44:     buildTypes {
45:         release {
46:             signingConfig signingConfigs.debug
47:             minifyEnabled true
48:             shrinkResources true
49:             proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
50:             
51:             manifestPlaceholders = [
52:                 applicationName: "io.flutter.app.FlutterApplication",
53:                 appName: "FFTCG Companion"
54:             ]
55:         }
56:         debug {
57:             minifyEnabled false
58:             shrinkResources false
59:             manifestPlaceholders = [
60:                 applicationName: "io.flutter.app.FlutterApplication",
61:                 appName: "FFTCG Companion Debug"
62:             ]
63:         }
64:     }
65: }
66: 
67: flutter {
68:     source '../..'
69: }
70: 
71: dependencies {
72:     implementation platform('com.google.firebase:firebase-bom:32.7.2')
73:     implementation 'com.google.firebase:firebase-analytics'
74:     implementation 'com.google.firebase:firebase-auth'
75:     implementation 'com.google.firebase:firebase-firestore'
76:     implementation 'com.google.firebase:firebase-storage'
77:     implementation 'com.google.android.gms:play-services-base:18.2.0'
78:     implementation 'com.google.android.gms:play-services-auth:20.7.0'
79:     implementation 'com.google.firebase:firebase-appcheck-playintegrity'
80:     debugImplementation 'com.google.firebase:firebase-appcheck-debug:17.1.1'  // For debug builds only
81:     implementation 'androidx.multidex:multidex:2.0.1'    
82: }
</file>

<file path="android/app/proguard-rules.pro">
 1: # android/app/proguard-rules.pro
 2: -keep class io.flutter.app.** { *; }
 3: -keep class io.flutter.plugin.**  { *; }
 4: -keep class io.flutter.util.**  { *; }
 5: -keep class io.flutter.view.**  { *; }
 6: -keep class io.flutter.**  { *; }
 7: -keep class io.flutter.plugins.**  { *; }
 8: -keep class com.google.firebase.** { *; }
 9: 
10: # Firebase Authentication
11: -keepattributes Signature
12: -keepattributes *Annotation*
13: -keepattributes EnclosingMethod
14: -keepattributes InnerClasses
15: 
16: # Firebase Firestore
17: -keep class com.google.firebase.firestore.** { *; }
18: -keep class com.google.firebase.firestore.model.** { *; }
19: 
20: # Firebase Storage
21: -keep class com.google.firebase.storage.** { *; }
22: 
23: # Hive
24: -keep class * extends com.google.protobuf.GeneratedMessageLite { *; }
25: -keep class * extends io.hive.** { *; }
26: 
27: # Workmanager
28: -keep class androidx.work.** { *; }
29: 
30: # Google Sign In
31: -keep class com.google.android.gms.auth.** { *; }
</file>

<file path="android/app/src/debug/AndroidManifest.xml">
1: <manifest xmlns:android="http://schemas.android.com/apk/res/android">
2:     <!-- The INTERNET permission is required for development. Specifically,
3:          the Flutter tool needs it to communicate with the running application
4:          to allow setting breakpoints, to provide hot reload, etc.
5:     -->
6:     <uses-permission android:name="android.permission.INTERNET"/>
7: </manifest>
</file>

<file path="android/app/src/main/AndroidManifest.xml">
 1: <manifest xmlns:android="http://schemas.android.com/apk/res/android">
 2:     <uses-permission android:name="android.permission.INTERNET"/>
 3:     <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
 4:     <uses-permission android:name="android.permission.WAKE_LOCK"/>
 5:     
 6:     <application
 7:         android:name="${applicationName}"
 8:         android:label="FFTCG Companion"
 9:         android:icon="@mipmap/ic_launcher"
10:         android:allowBackup="true"
11:         android:fullBackupContent="@xml/backup_rules"
12:         android:networkSecurityConfig="@xml/network_security_config"
13:         android:enableOnBackInvokedCallback="true">
14:         
15:         <activity
16:             android:name=".MainActivity"
17:             android:exported="true"
18:             android:launchMode="singleTop"
19:             android:theme="@style/LaunchTheme"
20:             android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
21:             android:hardwareAccelerated="true"
22:             android:windowSoftInputMode="adjustResize">
23:             
24:             <meta-data
25:               android:name="io.flutter.embedding.android.NormalTheme"
26:               android:resource="@style/NormalTheme"
27:               />
28:             <intent-filter>
29:                 <action android:name="android.intent.action.MAIN"/>
30:                 <category android:name="android.intent.category.LAUNCHER"/>
31:             </intent-filter>
32:         </activity>
33:         
34:         <meta-data
35:             android:name="flutterEmbedding"
36:             android:value="2" />
37:     </application>
38: </manifest>
</file>

<file path="android/app/src/main/java/io/flutter/plugins/GeneratedPluginRegistrant.java">
 1: package io.flutter.plugins;
 2: 
 3: import androidx.annotation.Keep;
 4: import androidx.annotation.NonNull;
 5: import io.flutter.Log;
 6: 
 7: import io.flutter.embedding.engine.FlutterEngine;
 8: 
 9: /**
10:  * Generated file. Do not edit.
11:  * This file is generated by the Flutter tool based on the
12:  * plugins that support the Android platform.
13:  */
14: @Keep
15: public final class GeneratedPluginRegistrant {
16:   private static final String TAG = "GeneratedPluginRegistrant";
17:   public static void registerWith(@NonNull FlutterEngine flutterEngine) {
18:     try {
19:       flutterEngine.getPlugins().add(new io.flutter.plugins.firebase.firestore.FlutterFirebaseFirestorePlugin());
20:     } catch (Exception e) {
21:       Log.e(TAG, "Error registering plugin cloud_firestore, io.flutter.plugins.firebase.firestore.FlutterFirebaseFirestorePlugin", e);
22:     }
23:     try {
24:       flutterEngine.getPlugins().add(new dev.fluttercommunity.plus.connectivity.ConnectivityPlugin());
25:     } catch (Exception e) {
26:       Log.e(TAG, "Error registering plugin connectivity_plus, dev.fluttercommunity.plus.connectivity.ConnectivityPlugin", e);
27:     }
28:     try {
29:       flutterEngine.getPlugins().add(new dev.fluttercommunity.plus.device_info.DeviceInfoPlusPlugin());
30:     } catch (Exception e) {
31:       Log.e(TAG, "Error registering plugin device_info_plus, dev.fluttercommunity.plus.device_info.DeviceInfoPlusPlugin", e);
32:     }
33:     try {
34:       flutterEngine.getPlugins().add(new io.flutter.plugins.firebase.appcheck.FlutterFirebaseAppCheckPlugin());
35:     } catch (Exception e) {
36:       Log.e(TAG, "Error registering plugin firebase_app_check, io.flutter.plugins.firebase.appcheck.FlutterFirebaseAppCheckPlugin", e);
37:     }
38:     try {
39:       flutterEngine.getPlugins().add(new io.flutter.plugins.firebase.auth.FlutterFirebaseAuthPlugin());
40:     } catch (Exception e) {
41:       Log.e(TAG, "Error registering plugin firebase_auth, io.flutter.plugins.firebase.auth.FlutterFirebaseAuthPlugin", e);
42:     }
43:     try {
44:       flutterEngine.getPlugins().add(new io.flutter.plugins.firebase.core.FlutterFirebaseCorePlugin());
45:     } catch (Exception e) {
46:       Log.e(TAG, "Error registering plugin firebase_core, io.flutter.plugins.firebase.core.FlutterFirebaseCorePlugin", e);
47:     }
48:     try {
49:       flutterEngine.getPlugins().add(new io.flutter.plugins.firebase.crashlytics.FlutterFirebaseCrashlyticsPlugin());
50:     } catch (Exception e) {
51:       Log.e(TAG, "Error registering plugin firebase_crashlytics, io.flutter.plugins.firebase.crashlytics.FlutterFirebaseCrashlyticsPlugin", e);
52:     }
53:     try {
54:       flutterEngine.getPlugins().add(new io.flutter.plugins.firebase.storage.FlutterFirebaseStoragePlugin());
55:     } catch (Exception e) {
56:       Log.e(TAG, "Error registering plugin firebase_storage, io.flutter.plugins.firebase.storage.FlutterFirebaseStoragePlugin", e);
57:     }
58:     try {
59:       flutterEngine.getPlugins().add(new com.baseflow.googleapiavailability.GoogleApiAvailabilityPlugin());
60:     } catch (Exception e) {
61:       Log.e(TAG, "Error registering plugin google_api_availability_android, com.baseflow.googleapiavailability.GoogleApiAvailabilityPlugin", e);
62:     }
63:     try {
64:       flutterEngine.getPlugins().add(new io.flutter.plugins.googlesignin.GoogleSignInPlugin());
65:     } catch (Exception e) {
66:       Log.e(TAG, "Error registering plugin google_sign_in_android, io.flutter.plugins.googlesignin.GoogleSignInPlugin", e);
67:     }
68:     try {
69:       flutterEngine.getPlugins().add(new io.flutter.plugins.pathprovider.PathProviderPlugin());
70:     } catch (Exception e) {
71:       Log.e(TAG, "Error registering plugin path_provider_android, io.flutter.plugins.pathprovider.PathProviderPlugin", e);
72:     }
73:     try {
74:       flutterEngine.getPlugins().add(new dev.fluttercommunity.plus.share.SharePlusPlugin());
75:     } catch (Exception e) {
76:       Log.e(TAG, "Error registering plugin share_plus, dev.fluttercommunity.plus.share.SharePlusPlugin", e);
77:     }
78:     try {
79:       flutterEngine.getPlugins().add(new io.flutter.plugins.sharedpreferences.SharedPreferencesPlugin());
80:     } catch (Exception e) {
81:       Log.e(TAG, "Error registering plugin shared_preferences_android, io.flutter.plugins.sharedpreferences.SharedPreferencesPlugin", e);
82:     }
83:     try {
84:       flutterEngine.getPlugins().add(new com.tekartik.sqflite.SqflitePlugin());
85:     } catch (Exception e) {
86:       Log.e(TAG, "Error registering plugin sqflite_android, com.tekartik.sqflite.SqflitePlugin", e);
87:     }
88:     try {
89:       flutterEngine.getPlugins().add(new dev.fluttercommunity.workmanager.WorkmanagerPlugin());
90:     } catch (Exception e) {
91:       Log.e(TAG, "Error registering plugin workmanager, dev.fluttercommunity.workmanager.WorkmanagerPlugin", e);
92:     }
93:   }
94: }
</file>

<file path="android/app/src/main/kotlin/com/example/fftcg_companion_app/MainActivity.kt">
1: package com.example.fftcg_companion_app
2: 
3: import io.flutter.embedding.android.FlutterActivity
4: 
5: class MainActivity: FlutterActivity()
</file>

<file path="android/app/src/main/kotlin/com/mrw1986/fftcg_companion_app/MainActivity.kt">
1: package com.mrw1986.fftcg_companion_app
2: 
3: import io.flutter.embedding.android.FlutterActivity
4: 
5: class MainActivity: FlutterActivity()
</file>

<file path="android/app/src/main/res/drawable-v21/launch_background.xml">
 1: <?xml version="1.0" encoding="utf-8"?>
 2: <!-- Modify this file to customize your launch splash screen -->
 3: <layer-list xmlns:android="http://schemas.android.com/apk/res/android">
 4:     <item android:drawable="?android:colorBackground" />
 5: 
 6:     <!-- You can insert your own image assets here -->
 7:     <!-- <item>
 8:         <bitmap
 9:             android:gravity="center"
10:             android:src="@mipmap/launch_image" />
11:     </item> -->
12: </layer-list>
</file>

<file path="android/app/src/main/res/drawable/launch_background.xml">
 1: <?xml version="1.0" encoding="utf-8"?>
 2: <!-- Modify this file to customize your launch splash screen -->
 3: <layer-list xmlns:android="http://schemas.android.com/apk/res/android">
 4:     <item android:drawable="@android:color/white" />
 5: 
 6:     <!-- You can insert your own image assets here -->
 7:     <!-- <item>
 8:         <bitmap
 9:             android:gravity="center"
10:             android:src="@mipmap/launch_image" />
11:     </item> -->
12: </layer-list>
</file>

<file path="android/app/src/main/res/values-night/styles.xml">
 1: <?xml version="1.0" encoding="utf-8"?>
 2: <resources>
 3:     <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
 4:     <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
 5:         <!-- Show a splash screen on the activity. Automatically removed when
 6:              the Flutter engine draws its first frame -->
 7:         <item name="android:windowBackground">@drawable/launch_background</item>
 8:     </style>
 9:     <!-- Theme applied to the Android Window as soon as the process has started.
10:          This theme determines the color of the Android Window while your
11:          Flutter UI initializes, as well as behind your Flutter UI while its
12:          running.
13: 
14:          This Theme is only used starting with V2 of Flutter's Android embedding. -->
15:     <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
16:         <item name="android:windowBackground">?android:colorBackground</item>
17:     </style>
18: </resources>
</file>

<file path="android/app/src/main/res/values/styles.xml">
 1: <?xml version="1.0" encoding="utf-8"?>
 2: <resources>
 3:     <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
 4:     <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
 5:         <!-- Show a splash screen on the activity. Automatically removed when
 6:              the Flutter engine draws its first frame -->
 7:         <item name="android:windowBackground">@drawable/launch_background</item>
 8:     </style>
 9:     <!-- Theme applied to the Android Window as soon as the process has started.
10:          This theme determines the color of the Android Window while your
11:          Flutter UI initializes, as well as behind your Flutter UI while its
12:          running.
13: 
14:          This Theme is only used starting with V2 of Flutter's Android embedding. -->
15:     <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
16:         <item name="android:windowBackground">?android:colorBackground</item>
17:     </style>
18: </resources>
</file>

<file path="android/app/src/main/res/xml/backup_rules.xml">
1: <?xml version="1.0" encoding="utf-8"?>
2: <full-backup-content>
3:     <exclude domain="sharedpref" path="WebView.xml"/>
4:     <exclude domain="database" path="google_app_measurement.db"/>
5:     <exclude domain="database" path="google_app_measurement_local.db"/>
6:     <exclude domain="root" path="gcm_key"/>
7:     <include domain="sharedpref" path="."/>
8:     <exclude domain="sharedpref" path="device.xml"/>
9: </full-backup-content>
</file>

<file path="android/app/src/main/res/xml/network_security_config.xml">
 1: <?xml version="1.0" encoding="utf-8"?>
 2: <network-security-config>
 3:     <debug-overrides>
 4:         <trust-anchors>
 5:             <certificates src="system" />
 6:             <certificates src="user" />
 7:         </trust-anchors>
 8:     </debug-overrides>
 9:     
10:     <base-config cleartextTrafficPermitted="false">
11:         <trust-anchors>
12:             <certificates src="system" />
13:         </trust-anchors>
14:     </base-config>
15:     
16:     <domain-config>
17:         <domain includeSubdomains="true">googleapis.com</domain>
18:         <domain includeSubdomains="true">firebaseio.com</domain>
19:         <domain includeSubdomains="true">firebaseappcheck.googleapis.com</domain>
20:         <domain includeSubdomains="true">firebase.googleapis.com</domain>
21:         <domain includeSubdomains="true">firestore.googleapis.com</domain>
22:         <domain includeSubdomains="true">google.com</domain>
23:         <trust-anchors>
24:             <certificates src="system" />
25:         </trust-anchors>
26:         <pin-set expiration="2025-12-31">
27:             <!-- Google's PKI -->
28:             <pin digest="SHA-256">YZPgTZ+woNCCCIW3LH2CxQeLzB/1m42QcCTBSdgayjs=</pin>
29:             <!-- Backup pin -->
30:             <pin digest="SHA-256">sx8gDxNyVB6VjzNvA0M9S1OKYk1cOiKjhGIQm8TZ4Cs=</pin>
31:         </pin-set>
32:     </domain-config>
33: </network-security-config>
</file>

<file path="android/app/src/profile/AndroidManifest.xml">
1: <manifest xmlns:android="http://schemas.android.com/apk/res/android">
2:     <!-- The INTERNET permission is required for development. Specifically,
3:          the Flutter tool needs it to communicate with the running application
4:          to allow setting breakpoints, to provide hot reload, etc.
5:     -->
6:     <uses-permission android:name="android.permission.INTERNET"/>
7: </manifest>
</file>

<file path="android/build.gradle">
 1: allprojects {
 2:     repositories {
 3:         google()
 4:         mavenCentral()
 5:     }
 6: }
 7: 
 8: rootProject.buildDir = '../build'
 9: subprojects {
10:     project.buildDir = "${rootProject.buildDir}/${project.name}"
11: }
12: subprojects {
13:     project.evaluationDependsOn(':app')
14: }
15: 
16: tasks.register("clean", Delete) {
17:     delete rootProject.buildDir
18: }
</file>

<file path="android/gradle.properties">
 1: # android/gradle.properties
 2: org.gradle.jvmargs=-Xmx4096m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
 3: org.gradle.parallel=true
 4: org.gradle.daemon=true
 5: org.gradle.caching=true
 6: android.useAndroidX=true
 7: android.enableJetifier=true
 8: android.nonTransitiveRClass=true
 9: android.defaults.buildfeatures.buildconfig=true
10: android.nonFinalResIds=false
</file>

<file path="android/gradle/wrapper/gradle-wrapper.properties">
1: # android/gradle/wrapper/gradle-wrapper.properties
2: distributionBase=GRADLE_USER_HOME
3: distributionPath=wrapper/dists
4: distributionUrl=https\://services.gradle.org/distributions/gradle-8.2-all.zip
5: zipStoreBase=GRADLE_USER_HOME
6: zipStorePath=wrapper/dists
</file>

<file path="android/settings.gradle">
 1: pluginManagement {
 2:     def flutterSdkPath = {
 3:         def properties = new Properties()
 4:         file("local.properties").withInputStream { properties.load(it) }
 5:         def flutterSdkPath = properties.getProperty("flutter.sdk")
 6:         assert flutterSdkPath != null, "flutter.sdk not set in local.properties"
 7:         return flutterSdkPath
 8:     }()
 9: 
10:     includeBuild("$flutterSdkPath/packages/flutter_tools/gradle")
11: 
12:     repositories {
13:         google()
14:         mavenCentral()
15:         gradlePluginPortal()
16:     }
17: }
18: 
19: plugins {
20:     id "dev.flutter.flutter-plugin-loader" version "1.0.0"
21:     id "com.android.application" version "8.1.0" apply false
22:     id "org.jetbrains.kotlin.android" version "1.8.22" apply false
23:     id "com.google.gms.google-services" version "4.4.0" apply false
24:     id "com.google.firebase.crashlytics" version "2.9.9" apply false
25: }
26: 
27: dependencyResolutionManagement {
28:     repositoriesMode.set(RepositoriesMode.PREFER_PROJECT)
29:     repositories {
30:         google()
31:         mavenCentral()
32:     }
33: }
34: 
35: rootProject.name = "android"
36: include ":app"
</file>

<file path="firebase.json">
1: {"flutter":{"platforms":{"android":{"default":{"projectId":"fftcg-sync-service","appId":"1:161248420888:android:4e38e135739ad9427d4f6d","fileOutput":"android/app/google-services.json"}},"dart":{"lib/firebase_options.dart":{"projectId":"fftcg-sync-service","configurations":{"android":"1:161248420888:android:4e38e135739ad9427d4f6d","ios":"1:161248420888:ios:69b3e0c02770910c7d4f6d"}}}}}}
</file>

<file path="flutter_launcher_icons_card.yaml">
 1: flutter_launcher_icons:
 2:   android: true
 3:   ios: true
 4:   image_path: "assets/icons/fftcg_card_icon.png"
 5:   min_sdk_android: 23
 6:   remove_alpha_ios: true
 7:   background_color: "#1A1A1A"  # Dark background color
 8:   web:
 9:     generate: false
10:   windows:
11:     generate: false
12:   macos:
13:     generate: false
14:   linux:
15:     generate: false
</file>

<file path="flutter_launcher_icons.yaml">
 1: # flutter pub run flutter_launcher_icons
 2: flutter_launcher_icons:
 3:   image_path: "assets/icon/icon.png"
 4: 
 5:   android: "launcher_icon"
 6:   # image_path_android: "assets/icon/icon.png"
 7:   min_sdk_android: 21 # android min sdk min:16, default 21
 8:   # adaptive_icon_background: "assets/icon/background.png"
 9:   # adaptive_icon_foreground: "assets/icon/foreground.png"
10:   # adaptive_icon_monochrome: "assets/icon/monochrome.png"
11: 
12:   ios: true
13:   # image_path_ios: "assets/icon/icon.png"
14:   remove_alpha_channel_ios: true
15:   # image_path_ios_dark_transparent: "assets/icon/icon_dark.png"
16:   # image_path_ios_tinted_grayscale: "assets/icon/icon_tinted.png"
17:   # desaturate_tinted_to_grayscale_ios: true
18: 
19:   web:
20:     generate: true
21:     image_path: "path/to/image.png"
22:     background_color: "#hexcode"
23:     theme_color: "#hexcode"
24: 
25:   windows:
26:     generate: true
27:     image_path: "path/to/image.png"
28:     icon_size: 48 # min:48, max:256, default: 48
29: 
30:   macos:
31:     generate: true
32:     image_path: "path/to/image.png"
</file>

<file path="lib/core/logging/logger_service.dart">
  1: // lib/core/logging/logger_service.dart
  2: import 'dart:io';
  3: import 'package:flutter/foundation.dart';
  4: import 'package:logging/logging.dart';
  5: import 'package:path_provider/path_provider.dart';
  6: import 'package:share_plus/share_plus.dart';
  7: 
  8: class LoggerService {
  9:   static final LoggerService _instance = LoggerService._internal();
 10:   static const String _logFileName = 'fftcg_companion.log';
 11:   static const String _errorLogFileName = 'fftcg_companion_error.log';
 12:   static const int _maxLogSizeBytes = 5 * 1024 * 1024; // 5MB
 13:   static const int _maxBackupFiles = 3;
 14: 
 15:   final Logger _logger = Logger('FFTCGCompanion');
 16:   File? _logFile;
 17:   File? _errorLogFile;
 18: 
 19:   factory LoggerService() {
 20:     return _instance;
 21:   }
 22: 
 23:   LoggerService._internal() {
 24:     _initializeLogger();
 25:   }
 26: 
 27:   Future<void> _initializeLogger() async {
 28:     final Directory appDocDir = await getApplicationDocumentsDirectory();
 29:     _logFile = File('${appDocDir.path}/$_logFileName');
 30:     _errorLogFile = File('${appDocDir.path}/$_errorLogFileName');
 31: 
 32:     // Perform log rotation on startup
 33:     await _rotateLogsIfNeeded();
 34: 
 35:     Logger.root.level = Level.ALL;
 36:     Logger.root.onRecord.listen((record) async {
 37:       final logMessage =
 38:           '${record.time}: ${record.level.name}: ${record.message}';
 39: 
 40:       if (kDebugMode) {
 41:         debugPrint(logMessage);
 42:       }
 43: 
 44:       if (_logFile != null) {
 45:         await _logFile!.writeAsString(
 46:           '$logMessage\n',
 47:           mode: FileMode.append,
 48:         );
 49:         await _rotateLogsIfNeeded();
 50:       }
 51: 
 52:       // Write severe logs to error log file
 53:       if (record.level >= Level.SEVERE && _errorLogFile != null) {
 54:         final errorMessage = '''
 55: ${record.time}: ${record.level.name}: ${record.message}
 56: ${record.error ?? ''}
 57: ${_formatStackTrace(record.stackTrace)}
 58: ----------------------------------------
 59: ''';
 60:         await _errorLogFile!.writeAsString(
 61:           errorMessage,
 62:           mode: FileMode.append,
 63:         );
 64:       }
 65:     });
 66:   }
 67: 
 68:   Future<void> _rotateLogsIfNeeded() async {
 69:     if (_logFile == null || !await _logFile!.exists()) return;
 70: 
 71:     final fileSize = await _logFile!.length();
 72:     if (fileSize > _maxLogSizeBytes) {
 73:       for (var i = _maxBackupFiles - 1; i >= 0; i--) {
 74:         final backupFile = File('${_logFile!.path}.$i');
 75:         if (await backupFile.exists()) {
 76:           if (i == _maxBackupFiles - 1) {
 77:             await backupFile.delete();
 78:           } else {
 79:             await backupFile.rename('${_logFile!.path}.${i + 1}');
 80:           }
 81:         }
 82:       }
 83: 
 84:       await _logFile!.rename('${_logFile!.path}.0');
 85:       _logFile = File(_logFile!.path);
 86:       await _logFile!.create();
 87:     }
 88:   }
 89: 
 90:   String _formatStackTrace(StackTrace? stackTrace) {
 91:     if (stackTrace == null) return '';
 92: 
 93:     return stackTrace.toString().split('\n').map((line) {
 94:       line = line.trim();
 95:       if (line.startsWith('#')) {
 96:         // Format stack trace lines for better readability
 97:         return '  $line';
 98:       }
 99:       return line;
100:     }).join('\n');
101:   }
102: 
103:   void info(String message) => _logger.info(message);
104:   void warning(String message) => _logger.warning(message);
105:   void severe(String message, [Object? error, StackTrace? stackTrace]) {
106:     _logger.severe(message, error, stackTrace);
107:   }
108: 
109:   void exception(String message, Exception exception,
110:       [StackTrace? stackTrace]) {
111:     final formattedMessage = '''
112: Exception: $message
113: Type: ${exception.runtimeType}
114: Details: ${exception.toString()}''';
115: 
116:     _logger.severe(
117:         formattedMessage, exception, stackTrace ?? StackTrace.current);
118:   }
119: 
120:   Future<void> shareLogs() async {
121:     try {
122:       final Directory tempDir = await getTemporaryDirectory();
123:       final File tempFile = File('${tempDir.path}/FFTCG_Companion_Logs.txt');
124: 
125:       final StringBuffer buffer = StringBuffer();
126: 
127:       if (_logFile != null && await _logFile!.exists()) {
128:         buffer.writeln('=== General Logs ===');
129:         buffer.writeln(await _logFile!.readAsString());
130:       }
131: 
132:       if (_errorLogFile != null && await _errorLogFile!.exists()) {
133:         buffer.writeln('=== Error Logs ===');
134:         buffer.writeln(await _errorLogFile!.readAsString());
135:       }
136: 
137:       await tempFile.writeAsString(buffer.toString());
138: 
139:       await Share.shareXFiles(
140:         [XFile(tempFile.path, mimeType: 'text/plain')],
141:         subject: 'FFTCG Companion Logs',
142:       );
143:     } catch (e, stack) {
144:       _logger.severe('Error sharing logs', e, stack);
145:     }
146:   }
147: 
148:   Future<String> getLogs({bool errorLogsOnly = false}) async {
149:     final StringBuffer buffer = StringBuffer();
150: 
151:     if (!errorLogsOnly && _logFile != null && await _logFile!.exists()) {
152:       buffer.writeln('=== General Logs ===');
153:       buffer.writeln(await _logFile!.readAsString());
154:     }
155: 
156:     if (_errorLogFile != null && await _errorLogFile!.exists()) {
157:       buffer.writeln('=== Error Logs ===');
158:       buffer.writeln(await _errorLogFile!.readAsString());
159:     }
160: 
161:     return buffer.toString().trim().isNotEmpty
162:         ? buffer.toString()
163:         : 'No logs available';
164:   }
165: 
166:   Future<void> clearLogs({bool errorLogsOnly = false}) async {
167:     if (!errorLogsOnly && _logFile != null && await _logFile!.exists()) {
168:       await _logFile!.writeAsString('');
169:     }
170: 
171:     if (_errorLogFile != null && await _errorLogFile!.exists()) {
172:       await _errorLogFile!.writeAsString('');
173:     }
174:   }
175: }
</file>

<file path="lib/core/models/sync_status.dart">
 1: import 'package:hive/hive.dart';
 2: 
 3: part 'sync_status.g.dart';
 4: 
 5: @HiveType(typeId: 0)
 6: enum SyncStatus {
 7:   @HiveField(0)
 8:   synced,
 9: 
10:   @HiveField(1)
11:   pending,
12: 
13:   @HiveField(2)
14:   error
15: }
</file>

<file path="lib/core/presentation/widgets/app_drawer.dart">
  1: import 'package:flutter/material.dart';
  2: import 'package:flutter_riverpod/flutter_riverpod.dart';
  3: import '../../../features/auth/providers/auth_providers.dart';
  4: 
  5: class AppDrawer extends ConsumerWidget {
  6:   final String currentRoute;
  7: 
  8:   const AppDrawer({super.key, required this.currentRoute});
  9: 
 10:   @override
 11:   Widget build(BuildContext context, WidgetRef ref) {
 12:     final user = ref.watch(currentUserProvider);
 13: 
 14:     return Drawer(
 15:       child: ListView(
 16:         padding: EdgeInsets.zero,
 17:         children: [
 18:           DrawerHeader(
 19:             decoration: BoxDecoration(
 20:               color: Theme.of(context).primaryColor,
 21:             ),
 22:             child: Column(
 23:               crossAxisAlignment: CrossAxisAlignment.start,
 24:               children: [
 25:                 CircleAvatar(
 26:                   radius: 30,
 27:                   child: Text(
 28:                     user?.displayName?.substring(0, 1).toUpperCase() ?? 'G',
 29:                     style: const TextStyle(fontSize: 24),
 30:                   ),
 31:                 ),
 32:                 const SizedBox(height: 10),
 33:                 Text(
 34:                   user?.displayName ?? 'Guest User',
 35:                   style: Theme.of(context).textTheme.titleLarge?.copyWith(
 36:                         color: Theme.of(context).colorScheme.onPrimary,
 37:                       ),
 38:                 ),
 39:                 Text(
 40:                   user?.email ?? 'Guest Session',
 41:                   style: Theme.of(context).textTheme.bodyMedium?.copyWith(
 42:                         color: Theme.of(context).colorScheme.onPrimary,
 43:                       ),
 44:                 ),
 45:               ],
 46:             ),
 47:           ),
 48:           _buildDrawerItem(
 49:             context: context,
 50:             icon: Icons.view_list,
 51:             title: 'Card Database',
 52:             route: '/cards',
 53:             currentRoute: currentRoute,
 54:           ),
 55:           _buildDrawerItem(
 56:             context: context,
 57:             icon: Icons.collections_bookmark,
 58:             title: 'My Collection',
 59:             route: '/collection',
 60:             currentRoute: currentRoute,
 61:           ),
 62:           _buildDrawerItem(
 63:             context: context,
 64:             icon: Icons.style,
 65:             title: 'Decks',
 66:             route: '/decks',
 67:             currentRoute: currentRoute,
 68:           ),
 69:           _buildDrawerItem(
 70:             context: context,
 71:             icon: Icons.camera_alt,
 72:             title: 'Card Scanner',
 73:             route: '/scanner',
 74:             currentRoute: currentRoute,
 75:           ),
 76:           const Divider(),
 77:           _buildDrawerItem(
 78:             context: context,
 79:             icon: Icons.person,
 80:             title: 'Profile',
 81:             route: '/profile',
 82:             currentRoute: currentRoute,
 83:           ),
 84:           _buildDrawerItem(
 85:             context: context,
 86:             icon: Icons.settings,
 87:             title: 'Settings',
 88:             route: '/settings',
 89:             currentRoute: currentRoute,
 90:           ),
 91:         ],
 92:       ),
 93:     );
 94:   }
 95: 
 96:   Widget _buildDrawerItem({
 97:     required BuildContext context,
 98:     required IconData icon,
 99:     required String title,
100:     required String route,
101:     required String currentRoute,
102:   }) {
103:     final isSelected = currentRoute == route;
104: 
105:     return ListTile(
106:       leading: Icon(
107:         icon,
108:         color: isSelected ? Theme.of(context).primaryColor : null,
109:       ),
110:       title: Text(
111:         title,
112:         style: isSelected
113:             ? TextStyle(color: Theme.of(context).primaryColor)
114:             : null,
115:       ),
116:       selected: isSelected,
117:       onTap: () {
118:         Navigator.pop(context); // Close drawer
119:         if (!isSelected) {
120:           Navigator.pushReplacementNamed(context, route);
121:         }
122:       },
123:     );
124:   }
125: }
</file>

<file path="lib/core/providers/app_providers.dart">
  1: import 'package:firebase_core/firebase_core.dart';
  2: import 'package:flutter_riverpod/flutter_riverpod.dart';
  3: import '../services/connectivity_service.dart';
  4: import '../services/sync_service.dart';
  5: import '../logging/logger_service.dart';
  6: import '../../firebase_options.dart';
  7: 
  8: final loggerProvider = Provider<LoggerService>((ref) {
  9:   return LoggerService();
 10: });
 11: 
 12: final initializationProvider = FutureProvider<bool>((ref) async {
 13:   final logger = ref.watch(loggerProvider);
 14: 
 15:   try {
 16:     logger.info('Initializing Firebase');
 17:     await Firebase.initializeApp(
 18:       options: DefaultFirebaseOptions.currentPlatform,
 19:     );
 20: 
 21:     logger.info('Performing initial sync');
 22:     await ref.read(syncServiceProvider).syncPendingChanges();
 23: 
 24:     logger.info('App initialization completed successfully');
 25:     return true;
 26:   } catch (e, stack) {
 27:     logger.severe('App initialization failed', e, stack);
 28:     return false;
 29:   }
 30: });
 31: 
 32: final connectivityStatusProvider = StreamProvider<bool>((ref) async* {
 33:   final logger = ref.watch(loggerProvider);
 34:   final connectivityService = ref.watch(connectivityServiceProvider);
 35:   
 36:   try {
 37:     await for (final status in connectivityService.connectivityStream) {
 38:       logger.info('Connectivity status changed: $status');
 39:       yield status;
 40:     }
 41:   } catch (e, stack) {
 42:     logger.severe('Error monitoring connectivity', e, stack);
 43:     yield false;
 44:   }
 45: });
 46: 
 47: final appStateProvider = StateNotifierProvider<AppStateNotifier, AppState>((ref) {
 48:   return AppStateNotifier(ref);
 49: });
 50: 
 51: class AppState {
 52:   final bool isInitialized;
 53:   final bool? _isOnline; // Make the field private
 54:   final String? error;
 55: 
 56:   const AppState({
 57:     this.isInitialized = false,
 58:     bool? isOnline, // Change parameter name
 59:     this.error,
 60:   }) : _isOnline = isOnline; // Initialize private field
 61: 
 62:   // Add a public getter
 63:   bool? get isOnline => _isOnline;
 64: 
 65:   AppState copyWith({
 66:     bool? isInitialized,
 67:     bool? isOnline,
 68:     String? error,
 69:   }) {
 70:     return AppState(
 71:       isInitialized: isInitialized ?? this.isInitialized,
 72:       isOnline: isOnline ?? _isOnline, // Use private field
 73:       error: error ?? this.error,
 74:     );
 75:   }
 76: }
 77: 
 78: class AppStateNotifier extends StateNotifier<AppState> {
 79:   final Ref _ref;
 80:   final LoggerService _logger;
 81: 
 82:   AppStateNotifier(this._ref)
 83:       : _logger = LoggerService(),
 84:         super(const AppState()) {
 85:     _initialize();
 86:   }
 87: 
 88:   Future<void> _initialize() async {
 89:     try {
 90:       final initializationStatus = await _ref.read(initializationProvider.future);
 91:       
 92:       if (!initializationStatus) {
 93:         state = state.copyWith(
 94:           error: 'Failed to initialize app',
 95:         );
 96:         return;
 97:       }
 98: 
 99:       // Start listening to connectivity
100:       _ref.listen(connectivityStatusProvider, (previous, next) {
101:         next.whenData((isOnline) {
102:           state = state.copyWith(isOnline: isOnline);
103:           if (isOnline) {
104:             _ref.read(syncServiceProvider).syncPendingChanges();
105:           }
106:         });
107:       });
108: 
109:       state = state.copyWith(
110:         isInitialized: true,
111:         error: null,
112:       );
113: 
114:       _logger.info('App state initialized successfully');
115:     } catch (e, stack) {
116:       _logger.severe('Error initializing app state', e, stack);
117:       state = state.copyWith(
118:         error: 'Failed to initialize app: ${e.toString()}',
119:       );
120:     }
121:   }
122: 
123:   Future<void> retryInitialization() async {
124:     state = const AppState();
125:     await _initialize();
126:   }
127: }
</file>

<file path="lib/core/services/connectivity_service.dart">
  1: import 'dart:async';
  2: import 'package:connectivity_plus/connectivity_plus.dart';
  3: import 'package:internet_connection_checker/internet_connection_checker.dart';
  4: import 'package:flutter_riverpod/flutter_riverpod.dart';
  5: import '../logging/logger_service.dart';
  6: 
  7: final connectivityServiceProvider = Provider<ConnectivityService>((ref) {
  8:   return ConnectivityService();
  9: });
 10: 
 11: class ConnectivityService {
 12:   final Connectivity _connectivity = Connectivity();
 13:   InternetConnectionChecker _connectionChecker = InternetConnectionChecker();
 14:   final LoggerService _logger = LoggerService();
 15: 
 16:   // Stream controllers
 17:   final _connectivityController = StreamController<bool>.broadcast();
 18:   bool _lastKnownStatus = false;
 19: 
 20:   ConnectivityService() {
 21:     _initializeConnectivityStream();
 22:   }
 23: 
 24:   void _initializeConnectivityStream() {
 25:     // Listen to connectivity changes
 26:     _connectivity.onConnectivityChanged.listen((result) async {
 27:       await _checkAndUpdateConnectivity(result);
 28:     });
 29: 
 30:     // Initial check
 31:     _connectivity.checkConnectivity().then((result) async {
 32:       await _checkAndUpdateConnectivity(result);
 33:     });
 34:   }
 35: 
 36:   Future<void> _checkAndUpdateConnectivity(
 37:       List<ConnectivityResult> results) async {
 38:     try {
 39:       bool hasConnection = false;
 40: 
 41:       // If we have any connection type other than none
 42:       if (!results.contains(ConnectivityResult.none)) {
 43:         // Verify actual internet connectivity
 44:         hasConnection = await _connectionChecker.hasConnection;
 45:       }
 46: 
 47:       // Only emit if status has changed
 48:       if (hasConnection != _lastKnownStatus) {
 49:         _lastKnownStatus = hasConnection;
 50:         _connectivityController.add(hasConnection);
 51:         _logger.info(
 52:             'Connectivity status changed: ${hasConnection ? 'online' : 'offline'}');
 53:       }
 54:     } catch (e, stackTrace) {
 55:       _logger.severe('Error checking connectivity', e, stackTrace);
 56:       // In case of error, assume we're offline
 57:       if (_lastKnownStatus) {
 58:         _lastKnownStatus = false;
 59:         _connectivityController.add(false);
 60:       }
 61:     }
 62:   }
 63: 
 64:   /// Stream of connectivity status changes
 65:   Stream<bool> get connectivityStream => _connectivityController.stream;
 66: 
 67:   /// Current connectivity status
 68:   Future<bool> get isConnected async {
 69:     try {
 70:       final results = await _connectivity.checkConnectivity();
 71:       if (results.contains(ConnectivityResult.none)) {
 72:         return false;
 73:       }
 74:       return await _connectionChecker.hasConnection;
 75:     } catch (e, stackTrace) {
 76:       _logger.severe('Error checking current connectivity', e, stackTrace);
 77:       return false;
 78:     }
 79:   }
 80: 
 81:   /// Check if we have a stable connection
 82:   Future<bool> hasStableConnection() async {
 83:     try {
 84:       // Check internet connection
 85:       final hasConnection = await _connectionChecker.hasConnection;
 86:       if (!hasConnection) return false;
 87: 
 88:       // Check specific host reachability
 89:       final hostReachable = await _connectionChecker.isHostReachable(
 90:         AddressCheckOptions(
 91:           hostname: 'google.com',
 92:           port: 443,
 93:           timeout: const Duration(seconds: 3),
 94:         ),
 95:       );
 96: 
 97:       return hostReachable.isSuccess;
 98:     } catch (e, stackTrace) {
 99:       _logger.severe('Error checking stable connection', e, stackTrace);
100:       return false;
101:     }
102:   }
103: 
104:   /// Configuration for connection checker
105:   Future<void> configureConnectionChecker({
106:     Duration? checkInterval,
107:     Duration? timeout,
108:     List<AddressCheckOptions>? addresses,
109:   }) async {
110:     try {
111:       if (checkInterval != null || timeout != null || addresses != null) {
112:         // Create a new instance with updated configuration
113:         _connectionChecker = InternetConnectionChecker.createInstance(
114:           checkInterval: checkInterval ?? _connectionChecker.checkInterval,
115:           checkTimeout: timeout ?? _connectionChecker.checkTimeout,
116:           addresses: addresses ?? _connectionChecker.addresses,
117:         );
118:         _logger.info('Connection checker configured successfully');
119:       }
120:     } catch (e, stackTrace) {
121:       _logger.severe('Error configuring connection checker', e, stackTrace);
122:     }
123:   }
124: 
125:   /// Get detailed connection status
126:   Future<ConnectionStatus> getDetailedConnectionStatus() async {
127:     try {
128:       final results = await _connectivity.checkConnectivity();
129:       final hasConnection = await _connectionChecker.hasConnection;
130: 
131:       return ConnectionStatus(
132:         isConnected: hasConnection,
133:         connectionTypes: results,
134:         lastChecked: DateTime.now(),
135:       );
136:     } catch (e, stackTrace) {
137:       _logger.severe('Error getting detailed connection status', e, stackTrace);
138:       return ConnectionStatus(
139:         isConnected: false,
140:         connectionTypes: [],
141:         lastChecked: DateTime.now(),
142:         error: e.toString(),
143:       );
144:     }
145:   }
146: 
147:   void dispose() {
148:     _connectivityController.close();
149:   }
150: }
151: 
152: class ConnectionStatus {
153:   final bool isConnected;
154:   final List<ConnectivityResult> connectionTypes;
155:   final DateTime lastChecked;
156:   final String? error;
157: 
158:   ConnectionStatus({
159:     required this.isConnected,
160:     required this.connectionTypes,
161:     required this.lastChecked,
162:     this.error,
163:   });
164: 
165:   bool get hasWifi => connectionTypes.contains(ConnectivityResult.wifi);
166:   bool get hasMobile => connectionTypes.contains(ConnectivityResult.mobile);
167:   bool get hasEthernet => connectionTypes.contains(ConnectivityResult.ethernet);
168:   bool get hasVPN => connectionTypes.contains(ConnectivityResult.vpn);
169:   bool get hasError => error != null;
170: 
171:   @override
172:   String toString() {
173:     return 'ConnectionStatus(isConnected: $isConnected, types: $connectionTypes, lastChecked: $lastChecked, error: $error)';
174:   }
175: }
176: 
177: // Provider for detailed connection status
178: final connectionStatusProvider = StreamProvider<ConnectionStatus>((ref) async* {
179:   final connectivityService = ref.watch(connectivityServiceProvider);
180: 
181:   // Initial status
182:   yield await connectivityService.getDetailedConnectionStatus();
183: 
184:   // Stream of updates
185:   await for (final _ in connectivityService.connectivityStream) {
186:     yield await connectivityService.getDetailedConnectionStatus();
187:   }
188: });
189: 
190: // Provider for simple connection status
191: final isConnectedProvider = StreamProvider<bool>((ref) {
192:   final connectivityService = ref.watch(connectivityServiceProvider);
193:   return connectivityService.connectivityStream;
194: });
</file>

<file path="lib/core/services/hive_service.dart">
  1: import 'package:hive_flutter/hive_flutter.dart';
  2: import '../logging/logger_service.dart';
  3: import '../../features/cards/models/fftcg_card.dart';
  4: import '../../features/cards/models/card_extended_data.dart';
  5: import '../../features/cards/models/card_image_metadata.dart';
  6: import '../models/sync_status.dart';
  7: 
  8: class HiveService {
  9:   static const String cardsBoxName = 'cards';
 10:   static const String userBoxName = 'user';
 11:   static const String syncStatusBoxName = 'sync_status';
 12:   
 13:   final LoggerService _logger;
 14:   bool _isInitialized = false;
 15: 
 16:   HiveService({LoggerService? logger}) : _logger = logger ?? LoggerService();
 17: 
 18:   Future<void> initialize() async {
 19:     if (_isInitialized) {
 20:       _logger.info('Hive already initialized');
 21:       return;
 22:     }
 23: 
 24:     try {
 25:       await Hive.initFlutter();
 26:       
 27:       // Register adapters if not already registered
 28:       if (!Hive.isAdapterRegistered(0)) {
 29:         Hive.registerAdapter(SyncStatusAdapter());
 30:       }
 31:       if (!Hive.isAdapterRegistered(1)) {
 32:         Hive.registerAdapter(FFTCGCardAdapter());
 33:       }
 34:       if (!Hive.isAdapterRegistered(2)) {
 35:         Hive.registerAdapter(CardExtendedDataAdapter());
 36:       }
 37:       if (!Hive.isAdapterRegistered(3)) {
 38:         Hive.registerAdapter(CardImageMetadataAdapter());
 39:       }
 40: 
 41:       // Open boxes
 42:       await Future.wait([
 43:         Hive.openBox<FFTCGCard>(cardsBoxName),
 44:         Hive.openBox(userBoxName),
 45:         Hive.openBox(syncStatusBoxName),
 46:       ]);
 47: 
 48:       _isInitialized = true;
 49:       _logger.info('Hive initialized successfully');
 50:     } catch (e, stackTrace) {
 51:       _logger.severe('Failed to initialize Hive', e, stackTrace);
 52:       rethrow;
 53:     }
 54:   }
 55: 
 56:   Future<void> closeBoxes() async {
 57:     try {
 58:       await Future.wait([
 59:         Hive.box<FFTCGCard>(cardsBoxName).close(),
 60:         Hive.box(userBoxName).close(),
 61:         Hive.box(syncStatusBoxName).close(),
 62:       ]);
 63:       _isInitialized = false;
 64:       _logger.info('Hive boxes closed successfully');
 65:     } catch (e, stackTrace) {
 66:       _logger.severe('Error closing Hive boxes', e, stackTrace);
 67:       rethrow;
 68:     }
 69:   }
 70: 
 71:   Box<FFTCGCard> getCardsBox() {
 72:     if (!_isInitialized) {
 73:       throw StateError('HiveService not initialized');
 74:     }
 75:     return Hive.box<FFTCGCard>(cardsBoxName);
 76:   }
 77: 
 78:   Box getUserBox() {
 79:     if (!_isInitialized) {
 80:       throw StateError('HiveService not initialized');
 81:     }
 82:     return Hive.box(userBoxName);
 83:   }
 84: 
 85:   Box getSyncStatusBox() {
 86:     if (!_isInitialized) {
 87:       throw StateError('HiveService not initialized');
 88:     }
 89:     return Hive.box(syncStatusBoxName);
 90:   }
 91: 
 92:   Future<void> clearAll() async {
 93:     try {
 94:       await Future.wait([
 95:         getCardsBox().clear(),
 96:         getUserBox().clear(),
 97:         getSyncStatusBox().clear(),
 98:       ]);
 99:       _logger.info('All Hive boxes cleared successfully');
100:     } catch (e, stackTrace) {
101:       _logger.severe('Error clearing Hive boxes', e, stackTrace);
102:       rethrow;
103:     }
104:   }
105: 
106:   Future<void> deleteBoxes() async {
107:     try {
108:       await closeBoxes();
109:       await Future.wait([
110:         Hive.deleteBoxFromDisk(cardsBoxName),
111:         Hive.deleteBoxFromDisk(userBoxName),
112:         Hive.deleteBoxFromDisk(syncStatusBoxName),
113:       ]);
114:       _logger.info('All Hive boxes deleted successfully');
115:     } catch (e, stackTrace) {
116:       _logger.severe('Error deleting Hive boxes', e, stackTrace);
117:       rethrow;
118:     }
119:   }
120: 
121:   // Card-specific methods
122:   Future<void> saveCard(FFTCGCard card) async {
123:     try {
124:       final box = getCardsBox();
125:       await box.put(card.cardNumber, card);
126:       _logger.info('Card saved successfully: ${card.cardNumber}');
127:     } catch (e, stackTrace) {
128:       _logger.severe('Error saving card', e, stackTrace);
129:       rethrow;
130:     }
131:   }
132: 
133:   Future<void> saveCards(List<FFTCGCard> cards) async {
134:     try {
135:       final box = getCardsBox();
136:       final cardsMap = {for (var card in cards) card.cardNumber: card};
137:       await box.putAll(cardsMap);
138:       _logger.info('${cards.length} cards saved successfully');
139:     } catch (e, stackTrace) {
140:       _logger.severe('Error saving cards', e, stackTrace);
141:       rethrow;
142:     }
143:   }
144: 
145:   FFTCGCard? getCard(String cardNumber) {
146:     try {
147:       final box = getCardsBox();
148:       return box.get(cardNumber);
149:     } catch (e, stackTrace) {
150:       _logger.severe('Error getting card', e, stackTrace);
151:       rethrow;
152:     }
153:   }
154: 
155:   List<FFTCGCard> getAllCards() {
156:     try {
157:       final box = getCardsBox();
158:       return box.values.toList();
159:     } catch (e, stackTrace) {
160:       _logger.severe('Error getting all cards', e, stackTrace);
161:       rethrow;
162:     }
163:   }
164: 
165:   Future<void> deleteCard(String cardNumber) async {
166:     try {
167:       final box = getCardsBox();
168:       await box.delete(cardNumber);
169:       _logger.info('Card deleted successfully: $cardNumber');
170:     } catch (e, stackTrace) {
171:       _logger.severe('Error deleting card', e, stackTrace);
172:       rethrow;
173:     }
174:   }
175: }
</file>

<file path="lib/core/services/sync_service.dart">
  1: import 'dart:async';
  2: import 'package:cloud_firestore/cloud_firestore.dart';
  3: import 'package:flutter_riverpod/flutter_riverpod.dart';
  4: import 'package:shared_preferences/shared_preferences.dart';
  5: import '../logging/logger_service.dart';
  6: import '../models/sync_status.dart';
  7: import 'hive_service.dart';
  8: import '../../features/cards/models/fftcg_card.dart';
  9: import '../../features/auth/providers/auth_providers.dart';
 10: import '../../features/auth/services/auth_service.dart';
 11: 
 12: class SyncService {
 13:   final HiveService _hiveService;
 14:   final LoggerService _logger;
 15:   final Ref _ref;
 16:   final FirebaseFirestore _firestore;
 17:   final AuthService _authService;
 18: 
 19:   Timer? _syncTimer;
 20:   bool _isSyncing = false;
 21: 
 22:   SyncService({
 23:     required HiveService hiveService,
 24:     required Ref ref,
 25:     FirebaseFirestore? firestore,
 26:     LoggerService? logger,
 27:     AuthService? authService,
 28:   })  : _hiveService = hiveService,
 29:         _ref = ref,
 30:         _firestore = firestore ?? FirebaseFirestore.instance,
 31:         _logger = logger ?? LoggerService(),
 32:         _authService = authService ?? AuthService();
 33: 
 34:   void dispose() {
 35:     stopPeriodicSync();
 36:   }
 37: 
 38:   void startPeriodicSync() {
 39:     _syncTimer?.cancel();
 40:     _syncTimer = Timer.periodic(
 41:       const Duration(minutes: 15),
 42:       (_) => syncPendingChanges(),
 43:     );
 44:     _logger.info('Started periodic sync');
 45:   }
 46: 
 47:   void stopPeriodicSync() {
 48:     _syncTimer?.cancel();
 49:     _syncTimer = null;
 50:     _logger.info('Stopped periodic sync');
 51:   }
 52: 
 53:   Future<void> syncPendingChanges() async {
 54:     if (_isSyncing) {
 55:       _logger.info('Sync already in progress, skipping');
 56:       return;
 57:     }
 58: 
 59:     _isSyncing = true;
 60:     _logger.info('Starting sync of pending changes');
 61: 
 62:     try {
 63:       final isGuest = await _authService.isGuestSession();
 64:       if (isGuest) {
 65:         _logger.info('Skipping sync for guest user');
 66:         return;
 67:       }
 68: 
 69:       final user = _ref.read(currentUserProvider);
 70:       if (user == null) {
 71:         _logger.info('No user logged in, skipping sync');
 72:         return;
 73:       }
 74: 
 75:       final pendingCards = _hiveService
 76:           .getAllCards()
 77:           .where((card) => card.syncStatus == SyncStatus.pending)
 78:           .toList();
 79: 
 80:       _logger.info('Found ${pendingCards.length} cards pending sync');
 81: 
 82:       if (pendingCards.isEmpty) {
 83:         return;
 84:       }
 85: 
 86:       // Process in batches of 500
 87:       for (var i = 0; i < pendingCards.length; i += 500) {
 88:         var batch = _firestore.batch();
 89:         final end =
 90:             (i + 500 < pendingCards.length) ? i + 500 : pendingCards.length;
 91:         final currentBatch = pendingCards.sublist(i, end);
 92: 
 93:         final userCardsCollection =
 94:             _firestore.collection('users').doc(user.id).collection('cards');
 95: 
 96:         for (final card in currentBatch) {
 97:           final docRef = userCardsCollection.doc(card.cardNumber);
 98:           batch.set(
 99:               docRef,
100:               {
101:                 ...card.toMap(),
102:                 'lastModified': FieldValue.serverTimestamp(),
103:                 'syncStatus': 'synced',
104:               },
105:               SetOptions(merge: true));
106:         }
107: 
108:         await batch.commit();
109:         await _updateLocalSyncStatus(currentBatch);
110:       }
111: 
112:       await _updateLastSyncTime();
113:       _logger.info('Sync completed successfully');
114:     } catch (e, stackTrace) {
115:       _logger.severe('Error during sync', e, stackTrace);
116:     } finally {
117:       _isSyncing = false;
118:     }
119:   }
120: 
121:   Future<void> _updateLocalSyncStatus(List<FFTCGCard> cards) async {
122:     for (final card in cards) {
123:       card.markSynced();
124:       await _hiveService.saveCard(card);
125:     }
126:   }
127: 
128:   Future<void> revertFailedConversion(String userId) async {
129:     try {
130:       _logger.info('Starting conversion revert for user: $userId');
131: 
132:       // Delete uploaded data
133:       await _firestore
134:           .collection('users')
135:           .doc(userId)
136:           .collection('cards')
137:           .get()
138:           .then((snapshot) {
139:         for (var doc in snapshot.docs) {
140:           doc.reference.delete();
141:         }
142:       });
143: 
144:       // Reset local sync status
145:       final localCards = _hiveService.getAllCards();
146:       for (final card in localCards) {
147:         card.markForSync();
148:         await _hiveService.saveCard(card);
149:       }
150: 
151:       _logger.info('Conversion revert completed successfully');
152:     } catch (e, stackTrace) {
153:       _logger.severe('Error reverting conversion', e, stackTrace);
154:       rethrow;
155:     }
156:   }
157: 
158:   Future<bool> isDataSynced() async {
159:     try {
160:       final localCards = _hiveService.getAllCards();
161:       return !localCards.any((card) =>
162:           card.syncStatus == SyncStatus.pending ||
163:           card.syncStatus == SyncStatus.error);
164:     } catch (e, stackTrace) {
165:       _logger.severe('Error checking sync status', e, stackTrace);
166:       return false;
167:     }
168:   }
169: 
170:   Future<void> resetSyncStatus() async {
171:     try {
172:       final localCards = _hiveService.getAllCards();
173:       for (final card in localCards) {
174:         card.markForSync();
175:         await _hiveService.saveCard(card);
176:       }
177:       _logger.info('Reset sync status for all cards');
178:     } catch (e, stackTrace) {
179:       _logger.severe('Error resetting sync status', e, stackTrace);
180:       rethrow;
181:     }
182:   }
183: 
184:   int getCardCount() {
185:     try {
186:       return _hiveService.getAllCards().length;
187:     } catch (e, stackTrace) {
188:       _logger.severe('Error getting card count', e, stackTrace);
189:       return 0;
190:     }
191:   }
192: 
193:   Future<DateTime?> getLastSyncTime() async {
194:     try {
195:       final prefs = await SharedPreferences.getInstance();
196:       final timestamp = prefs.getInt('last_sync_timestamp');
197:       return timestamp != null
198:           ? DateTime.fromMillisecondsSinceEpoch(timestamp)
199:           : null;
200:     } catch (e, stackTrace) {
201:       _logger.severe('Error getting last sync time', e, stackTrace);
202:       return null;
203:     }
204:   }
205: 
206:   Future<void> _updateLastSyncTime() async {
207:     try {
208:       final prefs = await SharedPreferences.getInstance();
209:       await prefs.setInt(
210:         'last_sync_timestamp',
211:         DateTime.now().millisecondsSinceEpoch,
212:       );
213:     } catch (e, stackTrace) {
214:       _logger.severe('Error updating last sync time', e, stackTrace);
215:     }
216:   }
217: 
218:   Future<SyncStatus> getSyncStatus() async {
219:     try {
220:       final localCards = _hiveService.getAllCards();
221:       if (localCards.isEmpty) return SyncStatus.synced;
222: 
223:       if (localCards.any((card) => card.syncStatus == SyncStatus.error)) {
224:         return SyncStatus.error;
225:       }
226: 
227:       if (localCards.any((card) => card.syncStatus == SyncStatus.pending)) {
228:         return SyncStatus.pending;
229:       }
230: 
231:       return SyncStatus.synced;
232:     } catch (e, stackTrace) {
233:       _logger.severe('Error getting sync status', e, stackTrace);
234:       return SyncStatus.error;
235:     }
236:   }
237: }
238: 
239: // Providers
240: final hiveServiceProvider = Provider<HiveService>((ref) {
241:   return HiveService();
242: });
243: 
244: final syncServiceProvider = Provider<SyncService>((ref) {
245:   final hiveService = ref.watch(hiveServiceProvider);
246:   return SyncService(
247:     hiveService: hiveService,
248:     ref: ref,
249:     authService: AuthService(),
250:   );
251: });
252: 
253: final syncStatusProvider = FutureProvider<bool>((ref) {
254:   final syncService = ref.watch(syncServiceProvider);
255:   return syncService.isDataSynced();
256: });
257: 
258: final lastSyncTimeProvider = FutureProvider<DateTime?>((ref) {
259:   final syncService = ref.watch(syncServiceProvider);
260:   return syncService.getLastSyncTime();
261: });
262: 
263: final cardCountProvider = Provider<int>((ref) {
264:   final syncService = ref.watch(syncServiceProvider);
265:   return syncService.getCardCount();
266: });
</file>

<file path="lib/core/theme/app_theme.dart">
 1: import 'package:flutter/material.dart';
 2: 
 3: class AppTheme {
 4:   static final ThemeData darkTheme = ThemeData(
 5:     useMaterial3: true,
 6:     brightness: Brightness.dark,
 7:     colorScheme: const ColorScheme.dark(
 8:       primary: Color(0xFFFF00FF), // Magenta
 9:       secondary: Color(0xFFCC00CC), // Darker Magenta
10:       tertiary: Color(0xFFFF66FF), // Dark Grey
11:       surface: Color(0xFF2C2C2C),
12:     ),
13:     scaffoldBackgroundColor: const Color(0xFF1A1A1A),
14:     appBarTheme: const AppBarTheme(
15:       backgroundColor: Color(0xFF1A1A1A),
16:       elevation: 0,
17:     ),
18:     cardTheme: const CardTheme(
19:       color: Color(0xFF2C2C2C),
20:       elevation: 2,
21:     ),
22:   );
23: }
</file>

<file path="lib/features/auth/enums/auth_status.dart">
1: enum AuthStatus {
2:   initial,
3:   authenticated,
4:   unauthenticated,
5:   guest,
6:   loading,
7:   error
8: }
</file>

<file path="lib/features/auth/models/auth_exception.dart">
 1: class CustomAuthException implements Exception {
 2:   final String code;
 3:   final String message;
 4:   final dynamic originalError;
 5: 
 6:   CustomAuthException({
 7:     required this.code,
 8:     required this.message,
 9:     this.originalError,
10:   });
11: 
12:   @override
13:   String toString() => 'AuthException: $message (Code: $code)';
14: }
</file>

<file path="lib/features/auth/presentation/auth_wrapper.dart">
  1: import 'dart:async';
  2: import 'package:flutter/material.dart';
  3: import 'package:flutter_riverpod/flutter_riverpod.dart';
  4: import '../enums/auth_status.dart';
  5: import '../providers/auth_providers.dart';
  6: import 'screens/login_screen.dart';
  7: import '../../cards/presentation/screens/cards_screen.dart';
  8: import '../../../core/logging/logger_service.dart';
  9: import '../../cards/providers/card_providers.dart';
 10: 
 11: class AuthWrapper extends ConsumerStatefulWidget {
 12:   const AuthWrapper({super.key});
 13: 
 14:   @override
 15:   ConsumerState<AuthWrapper> createState() => _AuthWrapperState();
 16: }
 17: 
 18: class _AuthWrapperState extends ConsumerState<AuthWrapper> {
 19:   final _logger = LoggerService();
 20:   Timer? _emailVerificationTimer;
 21: 
 22:   @override
 23:   void initState() {
 24:     super.initState();
 25:     _logger.info('AuthWrapper initialized');
 26:     _startEmailVerificationCheck();
 27:   }
 28: 
 29:   void _startEmailVerificationCheck() {
 30:     _emailVerificationTimer?.cancel();
 31:     _emailVerificationTimer = Timer.periodic(
 32:       const Duration(seconds: 5),
 33:       (_) {
 34:         final authState = ref.read(authNotifierProvider);
 35:         final user = authState.user;
 36: 
 37:         // Only check if we have a non-guest authenticated user who needs verification
 38:         if (authState.status == AuthStatus.authenticated &&
 39:             user != null &&
 40:             !user.isGuest &&
 41:             !user.isEmailVerified &&
 42:             user.email != null) {
 43:           ref.read(authNotifierProvider.notifier).checkEmailVerification();
 44:         }
 45:       },
 46:     );
 47:   }
 48: 
 49:   @override
 50:   void dispose() {
 51:     _emailVerificationTimer?.cancel();
 52:     super.dispose();
 53:   }
 54: 
 55:   Future<void> _handleLogout() async {
 56:     try {
 57:       final confirmed = await showDialog<bool>(
 58:         context: context,
 59:         builder: (context) => AlertDialog(
 60:           title: const Text('Logout'),
 61:           content: const Text('Are you sure you want to logout?'),
 62:           actions: [
 63:             TextButton(
 64:               onPressed: () => Navigator.pop(context, false),
 65:               child: const Text('Cancel'),
 66:             ),
 67:             TextButton(
 68:               onPressed: () => Navigator.pop(context, true),
 69:               child: const Text('Logout'),
 70:             ),
 71:           ],
 72:         ),
 73:       );
 74: 
 75:       if (confirmed == true && mounted) {
 76:         // Start loading state
 77:         await ref.read(authNotifierProvider.notifier).signOut();
 78: 
 79:         // Clear any cached data or state
 80:         ref.invalidate(cardNotifierProvider);
 81:       }
 82:     } catch (e) {
 83:       if (mounted) {
 84:         ScaffoldMessenger.of(context).showSnackBar(
 85:           SnackBar(content: Text('Error signing out: $e')),
 86:         );
 87:       }
 88:     }
 89:   }
 90: 
 91:   @override
 92:   Widget build(BuildContext context) {
 93:     final authState = ref.watch(authNotifierProvider);
 94: 
 95:     _logger.info('Auth status: ${authState.status}');
 96: 
 97:     switch (authState.status) {
 98:       case AuthStatus.authenticated:
 99:       case AuthStatus.guest:
100:         // Both authenticated and guest users see the CardsScreen
101:         return CardsScreen(handleLogout: _handleLogout);
102: 
103:       case AuthStatus.unauthenticated:
104:       case AuthStatus.error:
105:         return const LoginScreen();
106: 
107:       case AuthStatus.loading:
108:       case AuthStatus.initial:
109:         return const Scaffold(
110:           body: Center(
111:             child: CircularProgressIndicator(),
112:           ),
113:         );
114:     }
115:   }
116: }
</file>

<file path="lib/features/auth/presentation/screens/account_linking_screen.dart">
  1: import 'package:flutter/material.dart';
  2: import 'package:flutter_riverpod/flutter_riverpod.dart';
  3: import '../widgets/auth_button.dart';
  4: import '../widgets/auth_text_field.dart';
  5: import '../../providers/auth_providers.dart';
  6: import '../../enums/auth_status.dart';
  7: 
  8: class AccountLinkingScreen extends ConsumerStatefulWidget {
  9:   const AccountLinkingScreen({super.key});
 10: 
 11:   @override
 12:   ConsumerState<AccountLinkingScreen> createState() =>
 13:       _AccountLinkingScreenState();
 14: }
 15: 
 16: class _AccountLinkingScreenState extends ConsumerState<AccountLinkingScreen> {
 17:   final _formKey = GlobalKey<FormState>();
 18:   final _emailController = TextEditingController();
 19:   final _passwordController = TextEditingController();
 20: 
 21:   @override
 22:   void dispose() {
 23:     _emailController.dispose();
 24:     _passwordController.dispose();
 25:     super.dispose();
 26:   }
 27: 
 28:   Future<void> _linkWithGoogle() async {
 29:     try {
 30:       await ref.read(authNotifierProvider.notifier).linkWithGoogle();
 31:       if (mounted) {
 32:         ScaffoldMessenger.of(context).showSnackBar(
 33:           const SnackBar(content: Text('Successfully linked Google account')),
 34:         );
 35:         Navigator.pop(context);
 36:       }
 37:     } catch (e) {
 38:       if (mounted) {
 39:         ScaffoldMessenger.of(context).showSnackBar(
 40:           SnackBar(content: Text(e.toString())),
 41:         );
 42:       }
 43:     }
 44:   }
 45: 
 46:   Future<void> _linkWithEmailPassword() async {
 47:     if (_formKey.currentState?.validate() ?? false) {
 48:       try {
 49:         await ref.read(authNotifierProvider.notifier).linkWithEmailPassword(
 50:               _emailController.text.trim(),
 51:               _passwordController.text,
 52:             );
 53:         if (mounted) {
 54:           ScaffoldMessenger.of(context).showSnackBar(
 55:             const SnackBar(
 56:                 content: Text('Successfully linked email/password account')),
 57:           );
 58:           Navigator.pop(context);
 59:         }
 60:       } catch (e) {
 61:         if (mounted) {
 62:           ScaffoldMessenger.of(context).showSnackBar(
 63:             SnackBar(content: Text(e.toString())),
 64:           );
 65:         }
 66:       }
 67:     }
 68:   }
 69: 
 70:   @override
 71:   Widget build(BuildContext context) {
 72:     final authState = ref.watch(authNotifierProvider);
 73: 
 74:     return Scaffold(
 75:       appBar: AppBar(title: const Text('Link Additional Account')),
 76:       body: SingleChildScrollView(
 77:         padding: const EdgeInsets.all(16),
 78:         child: Column(
 79:           crossAxisAlignment: CrossAxisAlignment.stretch,
 80:           children: [
 81:             const Text(
 82:               'Link another account to access your data with multiple sign-in methods.',
 83:               style: TextStyle(fontSize: 16),
 84:             ),
 85:             const SizedBox(height: 24),
 86:             AuthButton(
 87:               text: 'Link Google Account',
 88:               onPressed: _linkWithGoogle,
 89:               isLoading: authState.status == AuthStatus.loading,
 90:             ),
 91:             const SizedBox(height: 24),
 92:             const Divider(),
 93:             const SizedBox(height: 24),
 94:             Form(
 95:               key: _formKey,
 96:               child: Column(
 97:                 children: [
 98:                   AuthTextField(
 99:                     controller: _emailController,
100:                     label: 'Email',
101:                     keyboardType: TextInputType.emailAddress,
102:                     validator: (value) {
103:                       if (value?.isEmpty ?? true) {
104:                         return 'Please enter your email';
105:                       }
106:                       if (!RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$')
107:                           .hasMatch(value!)) {
108:                         return 'Please enter a valid email';
109:                       }
110:                       return null;
111:                     },
112:                   ),
113:                   AuthTextField(
114:                     controller: _passwordController,
115:                     label: 'Password',
116:                     isPassword: true,
117:                     validator: (value) {
118:                       if (value?.isEmpty ?? true) {
119:                         return 'Please enter your password';
120:                       }
121:                       if (value!.length < 6) {
122:                         return 'Password must be at least 6 characters';
123:                       }
124:                       return null;
125:                     },
126:                   ),
127:                   const SizedBox(height: 16),
128:                   AuthButton(
129:                     text: 'Link Email/Password Account',
130:                     onPressed: _linkWithEmailPassword,
131:                     isLoading: authState.status == AuthStatus.loading,
132:                   ),
133:                 ],
134:               ),
135:             ),
136:           ],
137:         ),
138:       ),
139:     );
140:   }
141: }
</file>

<file path="lib/features/auth/presentation/screens/login_screen.dart">
  1: // lib/features/auth/presentation/screens/login_screen.dart
  2: import 'package:firebase_auth/firebase_auth.dart';
  3: import 'package:flutter/material.dart';
  4: import 'package:flutter_riverpod/flutter_riverpod.dart';
  5: import '../../enums/auth_status.dart';
  6: import '../../providers/auth_providers.dart';
  7: import '../widgets/auth_button.dart';
  8: import '../widgets/auth_text_field.dart';
  9: import '../widgets/auth_error_widget.dart';
 10: import '../../../../core/logging/logger_service.dart';
 11: import 'registration_screen.dart';
 12: import '../../../settings/presentation/screens/logs_viewer_screen.dart';
 13: import 'package:flutter/foundation.dart' show kDebugMode;
 14: 
 15: class LoginScreen extends ConsumerStatefulWidget {
 16:   const LoginScreen({super.key});
 17: 
 18:   @override
 19:   ConsumerState<LoginScreen> createState() => _LoginScreenState();
 20: }
 21: 
 22: class _LoginScreenState extends ConsumerState<LoginScreen> {
 23:   final _formKey = GlobalKey<FormState>();
 24:   final _emailController = TextEditingController();
 25:   final _passwordController = TextEditingController();
 26:   final _logger = LoggerService();
 27: 
 28:   @override
 29:   void initState() {
 30:     super.initState();
 31:     _logger.info('Login screen initialized');
 32:     WidgetsBinding.instance.addPostFrameCallback((_) {
 33:       ref.read(authNotifierProvider.notifier).clearError();
 34:     });
 35:   }
 36: 
 37:   @override
 38:   void dispose() {
 39:     _emailController.dispose();
 40:     _passwordController.dispose();
 41:     ref.read(authNotifierProvider.notifier).resetState();
 42:     super.dispose();
 43:   }
 44: 
 45:   String _getReadableAuthError(FirebaseAuthException e) {
 46:     switch (e.code) {
 47:       case 'invalid-credential':
 48:         return 'Invalid email or password. Please try again.';
 49:       case 'user-disabled':
 50:         return 'This account has been disabled. Please contact support.';
 51:       case 'user-not-found':
 52:         return 'No account found with this email. Please check your email or create an account.';
 53:       case 'wrong-password':
 54:         return 'Incorrect password. Please try again or use "Forgot Password?".';
 55:       case 'invalid-email':
 56:         return 'Please enter a valid email address.';
 57:       case 'network-request-failed':
 58:         return 'Network error. Please check your connection and try again.';
 59:       case 'too-many-requests':
 60:         return 'Too many attempts. Please try again later.';
 61:       default:
 62:         return e.message ?? 'An error occurred. Please try again.';
 63:     }
 64:   }
 65: 
 66:   Future<void> _handleEmailLogin() async {
 67:     if (_formKey.currentState?.validate() ?? false) {
 68:       try {
 69:         _logger.info('Attempting email login for: ${_emailController.text}');
 70:         await ref.read(authNotifierProvider.notifier).signInWithEmailPassword(
 71:               _emailController.text.trim(),
 72:               _passwordController.text,
 73:             );
 74:       } on FirebaseAuthException catch (e) {
 75:         _logger.severe('Firebase Auth Error: ${e.message}', e);
 76:         if (mounted) {
 77:           ScaffoldMessenger.of(context).showSnackBar(
 78:             SnackBar(content: Text(_getReadableAuthError(e))),
 79:           );
 80:         }
 81:       } catch (e, stackTrace) {
 82:         _logger.severe('Email login failed', e, stackTrace);
 83:         if (mounted) {
 84:           ScaffoldMessenger.of(context).showSnackBar(
 85:             const SnackBar(
 86:                 content:
 87:                     Text('An unexpected error occurred. Please try again.')),
 88:           );
 89:         }
 90:       }
 91:     }
 92:   }
 93: 
 94:   Future<void> _handleGoogleLogin() async {
 95:     try {
 96:       _logger.info('Attempting Google sign-in');
 97:       await ref.read(authNotifierProvider.notifier).signInWithGoogle();
 98:     } on FirebaseAuthException catch (e) {
 99:       _logger.severe('Firebase Auth Error: ${e.message}', e);
100:       if (mounted) {
101:         ScaffoldMessenger.of(context).showSnackBar(
102:           SnackBar(content: Text(_getReadableAuthError(e))),
103:         );
104:       }
105:     } catch (e, stackTrace) {
106:       _logger.severe('Google sign-in failed', e, stackTrace);
107:       if (mounted) {
108:         ScaffoldMessenger.of(context).showSnackBar(
109:           const SnackBar(
110:               content: Text('An error occurred during Google sign-in')),
111:         );
112:       }
113:     }
114:   }
115: 
116:   Future<void> _handleGuestLogin() async {
117:     try {
118:       _logger.info('Attempting guest login');
119:       await ref.read(authNotifierProvider.notifier).signInAsGuest();
120:     } catch (e, stackTrace) {
121:       _logger.severe('Guest login failed', e, stackTrace);
122:       if (mounted) {
123:         ScaffoldMessenger.of(context).showSnackBar(
124:           const SnackBar(content: Text('Failed to continue as guest')),
125:         );
126:       }
127:     }
128:   }
129: 
130:   Future<void> _handlePasswordReset() async {
131:     if (_emailController.text.isEmpty) {
132:       if (mounted) {
133:         ScaffoldMessenger.of(context).showSnackBar(
134:           const SnackBar(content: Text('Please enter your email address')),
135:         );
136:       }
137:       return;
138:     }
139: 
140:     try {
141:       _logger.info('Attempting password reset for: ${_emailController.text}');
142:       await FirebaseAuth.instance.sendPasswordResetEmail(
143:         email: _emailController.text.trim(),
144:       );
145: 
146:       if (mounted) {
147:         ScaffoldMessenger.of(context).showSnackBar(
148:           const SnackBar(content: Text('Password reset email sent')),
149:         );
150:       }
151:     } on FirebaseAuthException catch (e) {
152:       _logger.severe('Password reset failed: ${e.message}', e);
153:       if (mounted) {
154:         ScaffoldMessenger.of(context).showSnackBar(
155:           SnackBar(content: Text(_getReadableAuthError(e))),
156:         );
157:       }
158:     } catch (e, stackTrace) {
159:       _logger.severe('Password reset failed', e, stackTrace);
160:       if (mounted) {
161:         ScaffoldMessenger.of(context).showSnackBar(
162:           const SnackBar(content: Text('Failed to send password reset email')),
163:         );
164:       }
165:     }
166:   }
167: 
168:   @override
169:   Widget build(BuildContext context) {
170:     final authState = ref.watch(authNotifierProvider);
171: 
172:     return Scaffold(
173:       body: SafeArea(
174:         child: Center(
175:           child: SingleChildScrollView(
176:             padding: const EdgeInsets.all(24.0),
177:             child: Form(
178:               key: _formKey,
179:               child: Column(
180:                 mainAxisAlignment: MainAxisAlignment.center,
181:                 crossAxisAlignment: CrossAxisAlignment.stretch,
182:                 children: [
183:                   Text(
184:                     'FFTCG Companion',
185:                     style: Theme.of(context).textTheme.headlineMedium,
186:                     textAlign: TextAlign.center,
187:                   ),
188:                   const SizedBox(height: 48),
189:                   AuthTextField(
190:                     controller: _emailController,
191:                     label: 'Email',
192:                     keyboardType: TextInputType.emailAddress,
193:                     validator: (value) {
194:                       if (value?.isEmpty ?? true) {
195:                         return 'Please enter your email';
196:                       }
197:                       if (!RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$')
198:                           .hasMatch(value!)) {
199:                         return 'Please enter a valid email';
200:                       }
201:                       return null;
202:                     },
203:                   ),
204:                   AuthTextField(
205:                     controller: _passwordController,
206:                     label: 'Password',
207:                     isPassword: true,
208:                     validator: (value) {
209:                       if (value?.isEmpty ?? true) {
210:                         return 'Please enter your password';
211:                       }
212:                       if (value!.length < 6) {
213:                         return 'Password must be at least 6 characters';
214:                       }
215:                       return null;
216:                     },
217:                   ),
218:                   Align(
219:                     alignment: Alignment.centerRight,
220:                     child: TextButton(
221:                       onPressed: _handlePasswordReset,
222:                       child: const Text('Forgot Password?'),
223:                     ),
224:                   ),
225:                   const SizedBox(height: 24),
226:                   if (authState.errorMessage != null)
227:                     AuthErrorWidget(
228:                       message: authState.errorMessage!,
229:                     ),
230:                   AuthButton(
231:                     text: 'Sign In',
232:                     onPressed: _handleEmailLogin,
233:                     isLoading: authState.status == AuthStatus.loading,
234:                   ),
235:                   const SizedBox(height: 16),
236:                   const Text(
237:                     'Or',
238:                     textAlign: TextAlign.center,
239:                   ),
240:                   const SizedBox(height: 16),
241:                   AuthButton(
242:                     text: 'Continue with Google',
243:                     onPressed: _handleGoogleLogin,
244:                     isLoading: authState.status == AuthStatus.loading,
245:                     isOutlined: true,
246:                   ),
247:                   AuthButton(
248:                     text: 'Continue as Guest',
249:                     onPressed: _handleGuestLogin,
250:                     isLoading: authState.status == AuthStatus.loading,
251:                     isOutlined: true,
252:                   ),
253:                   TextButton(
254:                     onPressed: () {
255:                       Navigator.of(context).push(
256:                         MaterialPageRoute(
257:                           builder: (context) => const RegistrationScreen(),
258:                         ),
259:                       );
260:                     },
261:                     child: const Text('Create an Account'),
262:                   ),
263:                   if (kDebugMode)
264:                     IconButton(
265:                       icon: const Icon(Icons.bug_report),
266:                       onPressed: () {
267:                         Navigator.of(context).push(
268:                           MaterialPageRoute(
269:                             builder: (context) => const LogsViewerScreen(),
270:                           ),
271:                         );
272:                       },
273:                     ),
274:                 ],
275:               ),
276:             ),
277:           ),
278:         ),
279:       ),
280:     );
281:   }
282: }
</file>

<file path="lib/features/auth/presentation/screens/registration_screen.dart">
  1: // lib/features/auth/presentation/screens/registration_screen.dart
  2: import 'package:firebase_auth/firebase_auth.dart';
  3: import 'package:flutter/material.dart';
  4: import 'package:flutter_riverpod/flutter_riverpod.dart';
  5: import '../../enums/auth_status.dart';
  6: import '../../providers/auth_providers.dart';
  7: import '../widgets/auth_button.dart';
  8: import '../widgets/auth_text_field.dart';
  9: import '../widgets/auth_error_widget.dart';
 10: import '../../../../core/logging/logger_service.dart';
 11: import 'login_screen.dart';
 12: import 'account_linking_screen.dart';
 13: import '../widgets/account_exists_dialog.dart';
 14: 
 15: class RegistrationScreen extends ConsumerStatefulWidget {
 16:   const RegistrationScreen({super.key});
 17: 
 18:   @override
 19:   ConsumerState<RegistrationScreen> createState() => _RegistrationScreenState();
 20: }
 21: 
 22: class _RegistrationScreenState extends ConsumerState<RegistrationScreen> {
 23:   final _formKey = GlobalKey<FormState>();
 24:   final _displayNameController = TextEditingController();
 25:   final _emailController = TextEditingController();
 26:   final _passwordController = TextEditingController();
 27:   final _confirmPasswordController = TextEditingController();
 28:   final _logger = LoggerService();
 29: 
 30:   @override
 31:   void initState() {
 32:     super.initState();
 33:     _logger.info('Registration screen initialized');
 34:     WidgetsBinding.instance.addPostFrameCallback((_) {
 35:       ref.read(authNotifierProvider.notifier).clearError();
 36:     });
 37:   }
 38: 
 39:   @override
 40:   void dispose() {
 41:     _displayNameController.dispose();
 42:     _emailController.dispose();
 43:     _passwordController.dispose();
 44:     _confirmPasswordController.dispose();
 45:     ref.read(authNotifierProvider.notifier).resetState();
 46:     super.dispose();
 47:   }
 48: 
 49:   String _getReadableAuthError(FirebaseAuthException e) {
 50:     switch (e.code) {
 51:       case 'email-already-in-use':
 52:         return 'An account already exists with this email. Please sign in or use a different email.';
 53:       case 'invalid-email':
 54:         return 'Please enter a valid email address.';
 55:       case 'operation-not-allowed':
 56:         return 'This sign-in method is not enabled. Please contact support.';
 57:       case 'weak-password':
 58:         return 'Please choose a stronger password.';
 59:       case 'network-request-failed':
 60:         return 'Network error. Please check your connection and try again.';
 61:       default:
 62:         return e.message ?? 'An error occurred. Please try again.';
 63:     }
 64:   }
 65: 
 66:   Future<void> _handleRegistration() async {
 67:     if (_formKey.currentState?.validate() ?? false) {
 68:       try {
 69:         _logger.info('Attempting registration for: ${_emailController.text}');
 70: 
 71:         final result = await ref
 72:             .read(authNotifierProvider.notifier)
 73:             .registerWithEmailPassword(
 74:               _emailController.text.trim(),
 75:               _passwordController.text,
 76:               _displayNameController.text.trim(),
 77:             );
 78: 
 79:         if (!mounted) return;
 80: 
 81:         if (result == null) {
 82:           await showDialog(
 83:             context: context,
 84:             builder: (context) => AccountExistsDialog(
 85:               email: _emailController.text,
 86:               onLogin: () {
 87:                 Navigator.of(context).pushReplacement(
 88:                   MaterialPageRoute(
 89:                     builder: (context) => const LoginScreen(),
 90:                   ),
 91:                 );
 92:               },
 93:               onLink: () {
 94:                 final currentUser = ref.read(authNotifierProvider).user;
 95:                 if (currentUser?.isGuest ?? true) {
 96:                   ScaffoldMessenger.of(context).showSnackBar(
 97:                     const SnackBar(
 98:                       content: Text('Please sign in first to link accounts'),
 99:                     ),
100:                   );
101:                   return;
102:                 }
103: 
104:                 Navigator.of(context).push(
105:                   MaterialPageRoute(
106:                     builder: (context) => const AccountLinkingScreen(),
107:                   ),
108:                 );
109:               },
110:             ),
111:           );
112:         }
113:       } on FirebaseAuthException catch (e) {
114:         _logger.severe('Firebase Auth Error: ${e.message}', e);
115:         if (mounted) {
116:           ScaffoldMessenger.of(context).showSnackBar(
117:             SnackBar(content: Text(_getReadableAuthError(e))),
118:           );
119:         }
120:       } catch (e, stackTrace) {
121:         _logger.severe('Unexpected error during registration', e, stackTrace);
122:         if (mounted) {
123:           ScaffoldMessenger.of(context).showSnackBar(
124:             const SnackBar(
125:                 content:
126:                     Text('An unexpected error occurred. Please try again.')),
127:           );
128:         }
129:       }
130:     }
131:   }
132: 
133:   @override
134:   Widget build(BuildContext context) {
135:     final authState = ref.watch(authNotifierProvider);
136: 
137:     return Scaffold(
138:       appBar: AppBar(
139:         title: const Text('Create Account'),
140:       ),
141:       body: SafeArea(
142:         child: SingleChildScrollView(
143:           padding: const EdgeInsets.all(24.0),
144:           child: Form(
145:             key: _formKey,
146:             child: Column(
147:               crossAxisAlignment: CrossAxisAlignment.stretch,
148:               children: [
149:                 AuthTextField(
150:                   controller: _displayNameController,
151:                   label: 'Display Name',
152:                   validator: (value) {
153:                     if (value?.isEmpty ?? true) {
154:                       return 'Please enter a display name';
155:                     }
156:                     return null;
157:                   },
158:                 ),
159:                 AuthTextField(
160:                   controller: _emailController,
161:                   label: 'Email',
162:                   keyboardType: TextInputType.emailAddress,
163:                   validator: (value) {
164:                     if (value?.isEmpty ?? true) {
165:                       return 'Please enter your email';
166:                     }
167:                     if (!RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$')
168:                         .hasMatch(value!)) {
169:                       return 'Please enter a valid email';
170:                     }
171:                     return null;
172:                   },
173:                 ),
174:                 AuthTextField(
175:                   controller: _passwordController,
176:                   label: 'Password',
177:                   isPassword: true,
178:                   validator: (value) {
179:                     if (value?.isEmpty ?? true) {
180:                       return 'Please enter a password';
181:                     }
182:                     if (value!.length < 6) {
183:                       return 'Password must be at least 6 characters';
184:                     }
185:                     return null;
186:                   },
187:                 ),
188:                 AuthTextField(
189:                   controller: _confirmPasswordController,
190:                   label: 'Confirm Password',
191:                   isPassword: true,
192:                   validator: (value) {
193:                     if (value?.isEmpty ?? true) {
194:                       return 'Please confirm your password';
195:                     }
196:                     if (value != _passwordController.text) {
197:                       return 'Passwords do not match';
198:                     }
199:                     return null;
200:                   },
201:                 ),
202:                 const SizedBox(height: 24),
203:                 if (authState.errorMessage != null)
204:                   AuthErrorWidget(
205:                     message: authState.errorMessage!,
206:                   ),
207:                 AuthButton(
208:                   text: 'Create Account',
209:                   onPressed: _handleRegistration,
210:                   isLoading: authState.status == AuthStatus.loading,
211:                 ),
212:               ],
213:             ),
214:           ),
215:         ),
216:       ),
217:     );
218:   }
219: }
</file>

<file path="lib/features/auth/presentation/widgets/account_exists_dialog.dart">
 1: import 'package:flutter/material.dart';
 2: 
 3: class AccountExistsDialog extends StatelessWidget {
 4:   final String email;
 5:   final VoidCallback onLogin;
 6:   final VoidCallback onLink;
 7: 
 8:   const AccountExistsDialog({
 9:     super.key,
10:     required this.email,
11:     required this.onLogin,
12:     required this.onLink,
13:   });
14: 
15:   @override
16:   Widget build(BuildContext context) {
17:     return AlertDialog(
18:       title: const Text('Account Already Exists'),
19:       content: Text(
20:         'An account with email $email already exists. Would you like to sign in with that account or link it to your current account?',
21:       ),
22:       actions: [
23:         TextButton(
24:           onPressed: () => Navigator.of(context).pop(),
25:           child: const Text('Cancel'),
26:         ),
27:         TextButton(
28:           onPressed: () {
29:             Navigator.of(context).pop();
30:             onLogin();
31:           },
32:           child: const Text('Sign In'),
33:         ),
34:         TextButton(
35:           onPressed: () {
36:             Navigator.of(context).pop();
37:             onLink();
38:           },
39:           child: const Text('Link Account'),
40:         ),
41:       ],
42:     );
43:   }
44: }
</file>

<file path="lib/features/auth/presentation/widgets/auth_button.dart">
 1: import 'package:flutter/material.dart';
 2: 
 3: class AuthButton extends StatelessWidget {
 4:   final String text;
 5:   final VoidCallback onPressed;
 6:   final bool isLoading;
 7:   final bool isOutlined;
 8: 
 9:   const AuthButton({
10:     super.key,
11:     required this.text,
12:     required this.onPressed,
13:     this.isLoading = false,
14:     this.isOutlined = false,
15:   });
16: 
17:   @override
18:   Widget build(BuildContext context) {
19:     final Widget button = isOutlined
20:         ? OutlinedButton(
21:             onPressed: isLoading ? null : onPressed,
22:             style: OutlinedButton.styleFrom(
23:               padding: const EdgeInsets.symmetric(vertical: 16),
24:               shape: RoundedRectangleBorder(
25:                 borderRadius: BorderRadius.circular(12),
26:               ),
27:             ),
28:             child: _buildButtonContent(),
29:           )
30:         : ElevatedButton(
31:             onPressed: isLoading ? null : onPressed,
32:             style: ElevatedButton.styleFrom(
33:               padding: const EdgeInsets.symmetric(vertical: 16),
34:               shape: RoundedRectangleBorder(
35:                 borderRadius: BorderRadius.circular(12),
36:               ),
37:             ),
38:             child: _buildButtonContent(),
39:           );
40: 
41:     return Padding(
42:       padding: const EdgeInsets.symmetric(vertical: 8.0),
43:       child: SizedBox(
44:         width: double.infinity,
45:         child: button,
46:       ),
47:     );
48:   }
49: 
50:   Widget _buildButtonContent() {
51:     return isLoading
52:         ? const SizedBox(
53:             height: 20,
54:             width: 20,
55:             child: CircularProgressIndicator(
56:               strokeWidth: 2,
57:             ),
58:           )
59:         : Text(text);
60:   }
61: }
</file>

<file path="lib/features/auth/presentation/widgets/auth_error_widget.dart">
 1: import 'package:flutter/material.dart';
 2: 
 3: class AuthErrorWidget extends StatelessWidget {
 4:   final String message;
 5:   final VoidCallback? onRetry;
 6: 
 7:   const AuthErrorWidget({
 8:     super.key,
 9:     required this.message,
10:     this.onRetry,
11:   });
12: 
13:   @override
14:   Widget build(BuildContext context) {
15:     return Padding(
16:       padding: const EdgeInsets.all(16.0),
17:       child: Column(
18:         mainAxisSize: MainAxisSize.min,
19:         children: [
20:           Text(
21:             message,
22:             style: TextStyle(
23:               color: Theme.of(context).colorScheme.error,
24:               fontSize: 16,
25:             ),
26:             textAlign: TextAlign.center,
27:           ),
28:           if (onRetry != null) ...[
29:             const SizedBox(height: 16),
30:             TextButton.icon(
31:               onPressed: onRetry,
32:               icon: const Icon(Icons.refresh),
33:               label: const Text('Retry'),
34:             ),
35:           ],
36:         ],
37:       ),
38:     );
39:   }
40: }
</file>

<file path="lib/features/auth/presentation/widgets/auth_text_field.dart">
 1: import 'package:flutter/material.dart';
 2: 
 3: class AuthTextField extends StatelessWidget {
 4:   final TextEditingController controller;
 5:   final String label;
 6:   final bool isPassword;
 7:   final TextInputType keyboardType;
 8:   final String? Function(String?)? validator;
 9: 
10:   const AuthTextField({
11:     super.key,
12:     required this.controller,
13:     required this.label,
14:     this.isPassword = false,
15:     this.keyboardType = TextInputType.text,
16:     this.validator,
17:   });
18: 
19:   @override
20:   Widget build(BuildContext context) {
21:     return Padding(
22:       padding: const EdgeInsets.symmetric(vertical: 8.0),
23:       child: TextFormField(
24:         controller: controller,
25:         decoration: InputDecoration(
26:           labelText: label,
27:           border: OutlineInputBorder(
28:             borderRadius: BorderRadius.circular(12),
29:           ),
30:           filled: true,
31:         ),
32:         obscureText: isPassword,
33:         keyboardType: keyboardType,
34:         validator: validator,
35:         autovalidateMode: AutovalidateMode.onUserInteraction,
36:       ),
37:     );
38:   }
39: }
</file>

<file path="lib/features/auth/providers/auth_notifier.dart">
  1: import 'dart:async';
  2: import 'package:flutter_riverpod/flutter_riverpod.dart';
  3: import '../../../core/logging/logger_service.dart';
  4: import '../../../models/user_model.dart';
  5: import '../repositories/auth_repository.dart';
  6: import '../enums/auth_status.dart';
  7: import 'auth_state.dart';
  8: 
  9: class AuthNotifier extends StateNotifier<AuthState> {
 10:   final AuthRepository _authRepository;
 11:   final LoggerService _logger;
 12:   StreamSubscription? _authStateSubscription;
 13: 
 14:   AuthNotifier({
 15:     required AuthRepository authRepository,
 16:     LoggerService? logger,
 17:   })  : _authRepository = authRepository,
 18:         _logger = logger ?? LoggerService(),
 19:         super(AuthState()) {
 20:     _initialize();
 21:   }
 22: 
 23:   void _initialize() {
 24:     _authStateSubscription?.cancel();
 25:     _authStateSubscription = _authRepository.authStateChanges.listen(
 26:       (user) async {
 27:         if (user != null && user.isGuest) {
 28:           state = state.copyWith(status: AuthStatus.guest, user: user);
 29:         } else if (user != null) {
 30:           state = state.copyWith(status: AuthStatus.authenticated, user: user);
 31:         } else {
 32:           state =
 33:               state.copyWith(status: AuthStatus.unauthenticated, user: null);
 34:         }
 35:       },
 36:       onError: (error, stackTrace) {
 37:         _logger.severe('Auth state change error', error, stackTrace);
 38:         state = state.copyWith(
 39:           status: AuthStatus.error,
 40:           errorMessage: error.toString(),
 41:         );
 42:       },
 43:     );
 44:   }
 45: 
 46:   Future<void> signInWithGoogle() async {
 47:     try {
 48:       state = state.copyWith(
 49:         status: AuthStatus.loading,
 50:         errorMessage: null,
 51:       );
 52:       _logger.info('Attempting Google sign in');
 53: 
 54:       await _authRepository.signInWithGoogle();
 55:       _logger.info('Google sign in completed successfully');
 56:     } catch (e, stackTrace) {
 57:       _logger.severe('Error signing in with Google', e, stackTrace);
 58:       state = state.copyWith(
 59:         status: AuthStatus.error,
 60:         errorMessage: 'Failed to sign in with Google',
 61:       );
 62:       rethrow;
 63:     }
 64:   }
 65: 
 66:   Future<void> signInWithEmailPassword(String email, String password) async {
 67:     try {
 68:       state = state.copyWith(
 69:         status: AuthStatus.loading,
 70:         errorMessage: null,
 71:       );
 72:       _logger.info('Attempting email/password sign in');
 73: 
 74:       await _authRepository.signInWithEmailPassword(email, password);
 75:       _logger.info('Email/password sign in completed successfully');
 76:     } catch (e, stackTrace) {
 77:       _logger.severe('Error signing in with email/password', e, stackTrace);
 78:       state = state.copyWith(
 79:         status: AuthStatus.error,
 80:         errorMessage: 'Invalid email or password',
 81:       );
 82:       rethrow;
 83:     }
 84:   }
 85: 
 86:   Future<void> signInAsGuest() async {
 87:     try {
 88:       state = state.copyWith(
 89:         status: AuthStatus.loading,
 90:         errorMessage: null,
 91:       );
 92:       _logger.info('Attempting guest sign in');
 93: 
 94:       final guestUser = await _authRepository.signInAsGuest();
 95:       if (guestUser != null) {
 96:         state = state.copyWith(
 97:           status: AuthStatus.guest,
 98:           user: guestUser,
 99:           errorMessage: null,
100:         );
101:         _logger.info('Guest sign in completed successfully: ${guestUser.id}');
102:       } else {
103:         throw Exception('Failed to create guest session');
104:       }
105:     } catch (e, stackTrace) {
106:       _logger.severe('Error signing in as guest', e, stackTrace);
107:       state = state.copyWith(
108:         status: AuthStatus.error,
109:         errorMessage: 'Failed to continue as guest',
110:       );
111:       rethrow;
112:     }
113:   }
114: 
115:   Future<void> signOut() async {
116:     try {
117:       state = state.copyWith(
118:         status: AuthStatus.loading,
119:         errorMessage: null,
120:       );
121:       _logger.info('Attempting sign out');
122: 
123:       await _authRepository.signOut();
124: 
125:       state = state.copyWith(
126:         status: AuthStatus.unauthenticated,
127:         user: null,
128:         errorMessage: null,
129:       );
130:       _logger.info('Sign out completed successfully');
131:     } catch (e, stackTrace) {
132:       _logger.severe('Error signing out', e, stackTrace);
133:       state = state.copyWith(
134:         status: AuthStatus.error,
135:         errorMessage: 'Failed to sign out',
136:       );
137:       rethrow;
138:     }
139:   }
140: 
141:   Future<UserModel?> registerWithEmailPassword(
142:     String email,
143:     String password,
144:     String displayName,
145:   ) async {
146:     try {
147:       state = state.copyWith(
148:         status: AuthStatus.loading,
149:         errorMessage: null,
150:       );
151:       _logger.info('Attempting user registration');
152: 
153:       final user = await _authRepository.registerWithEmailPassword(
154:         email,
155:         password,
156:         displayName,
157:       );
158: 
159:       if (user == null) {
160:         state = state.copyWith(
161:           status: AuthStatus.unauthenticated,
162:           errorMessage: null,
163:         );
164:       } else {
165:         _logger.info('User registration completed successfully');
166:       }
167:       return user;
168:     } catch (e, stackTrace) {
169:       _logger.severe('Error registering with email/password', e, stackTrace);
170:       state = state.copyWith(
171:         status: AuthStatus.error,
172:         errorMessage: 'Failed to create account',
173:       );
174:       rethrow;
175:     }
176:   }
177: 
178:   Future<void> checkEmailVerification() async {
179:     try {
180:       await _authRepository.checkEmailVerification();
181:     } catch (e, stackTrace) {
182:       _logger.severe('Error checking email verification', e, stackTrace);
183:       state = state.copyWith(
184:         status: AuthStatus.error,
185:         errorMessage: 'Failed to check email verification',
186:       );
187:     }
188:   }
189: 
190:   Future<void> sendEmailVerification() async {
191:     try {
192:       await _authRepository.sendEmailVerification();
193:       _logger.info('Email verification sent');
194:     } catch (e, stackTrace) {
195:       _logger.severe('Error sending email verification', e, stackTrace);
196:       state = state.copyWith(
197:         status: AuthStatus.error,
198:         errorMessage: 'Failed to send verification email',
199:       );
200:     }
201:   }
202: 
203:   void clearError() {
204:     state = state.copyWith(
205:       errorMessage: null,
206:       status: state.user != null
207:           ? AuthStatus.authenticated
208:           : AuthStatus.unauthenticated,
209:     );
210:   }
211: 
212:   Future<void> linkWithGoogle() async {
213:     try {
214:       state = state.copyWith(status: AuthStatus.loading);
215:       await _authRepository.linkWithGoogle();
216:     } catch (e) {
217:       state = state.copyWith(
218:         status: AuthStatus.error,
219:         errorMessage: e.toString(),
220:       );
221:       rethrow;
222:     }
223:   }
224: 
225:   Future<void> linkWithEmailPassword(String email, String password) async {
226:     try {
227:       state = state.copyWith(status: AuthStatus.loading);
228:       await _authRepository.linkWithEmailPassword(email, password);
229:     } catch (e) {
230:       state = state.copyWith(
231:         status: AuthStatus.error,
232:         errorMessage: e.toString(),
233:       );
234:       rethrow;
235:     }
236:   }
237: 
238:   void resetState() {
239:     state = AuthState();
240:   }
241: 
242:   @override
243:   void dispose() {
244:     _logger.info('Disposing AuthNotifier');
245:     _authStateSubscription?.cancel();
246:     super.dispose();
247:   }
248: }
</file>

<file path="lib/features/auth/providers/auth_providers.dart">
 1: import 'package:flutter_riverpod/flutter_riverpod.dart';
 2: import '../repositories/auth_repository.dart';
 3: import '../enums/auth_status.dart'; // Added missing import
 4: import 'auth_notifier.dart';
 5: import 'auth_state.dart';
 6: 
 7: final authRepositoryProvider = Provider<AuthRepository>((ref) {
 8:   return AuthRepository();
 9: });
10: 
11: final authNotifierProvider =
12:     StateNotifierProvider<AuthNotifier, AuthState>((ref) {
13:   return AuthNotifier(
14:     authRepository: ref.watch(authRepositoryProvider),
15:   );
16: });
17: 
18: final authStatusProvider = Provider<AuthStatus>((ref) {
19:   return ref.watch(authNotifierProvider).status;
20: });
21: 
22: final currentUserProvider = Provider((ref) {
23:   return ref.watch(authNotifierProvider).user;
24: });
</file>

<file path="lib/features/auth/providers/auth_state.dart">
 1: import '../../../models/user_model.dart';
 2: import '../enums/auth_status.dart';
 3: 
 4: class AuthState {
 5:   final AuthStatus status;
 6:   final UserModel? user;
 7:   final String? errorMessage;
 8: 
 9:   AuthState({
10:     this.status = AuthStatus.initial,
11:     this.user,
12:     this.errorMessage,
13:   });
14: 
15:   AuthState copyWith({
16:     AuthStatus? status,
17:     UserModel? user,
18:     String? errorMessage,
19:   }) {
20:     return AuthState(
21:       status: status ?? this.status,
22:       user: user ?? this.user,
23:       errorMessage: errorMessage ?? this.errorMessage,
24:     );
25:   }
26: }
</file>

<file path="lib/features/auth/repositories/auth_repository.dart">
  1: import 'package:shared_preferences/shared_preferences.dart';
  2: import 'package:cloud_firestore/cloud_firestore.dart';
  3: import 'package:firebase_auth/firebase_auth.dart';
  4: import '../../../models/user_model.dart';
  5: import '../services/auth_service.dart';
  6: import '../../../core/logging/logger_service.dart';
  7: 
  8: class AuthRepository {
  9:   static const String _guestPrefsKey = 'guest_session';
 10:   final AuthService _authService;
 11:   final LoggerService _logger;
 12:   final FirebaseFirestore _firestore;
 13:   final FirebaseAuth _auth;
 14: 
 15:   AuthRepository({
 16:     AuthService? authService,
 17:     LoggerService? logger,
 18:     FirebaseFirestore? firestore,
 19:     FirebaseAuth? auth,
 20:   })  : _authService = authService ?? AuthService(),
 21:         _logger = logger ?? LoggerService(),
 22:         _firestore = firestore ?? FirebaseFirestore.instance,
 23:         _auth = auth ?? FirebaseAuth.instance;
 24: 
 25:   Future<bool> isGuestSession() async {
 26:     return _authService.isGuestSession();
 27:   }
 28: 
 29:   Stream<UserModel?> get authStateChanges => _authService.authStateChanges
 30:       .asyncMap((user) => user != null ? _authService.getCurrentUser() : null);
 31: 
 32:   Future<UserModel?> getCurrentUser() async {
 33:     try {
 34:       // Check for guest session first
 35:       final prefs = await SharedPreferences.getInstance();
 36:       final guestData = prefs.getString(_guestPrefsKey);
 37: 
 38:       if (guestData != null) {
 39:         _logger.info('Found guest session data');
 40:         try {
 41:           return UserModel.fromJson(guestData);
 42:         } catch (e) {
 43:           _logger.severe('Error parsing guest data', e);
 44:           await prefs.remove(_guestPrefsKey);
 45:         }
 46:       }
 47: 
 48:       // Check for authenticated user
 49:       final User? user = _auth.currentUser;
 50:       if (user == null) return null;
 51: 
 52:       final doc = await _firestore.collection('users').doc(user.uid).get();
 53:       if (doc.exists) {
 54:         return UserModel.fromFirestore(doc);
 55:       }
 56:       return null;
 57:     } catch (e, stackTrace) {
 58:       _logger.severe('Error getting current user', e, stackTrace);
 59:       return null;
 60:     }
 61:   }
 62: 
 63:   Future<UserModel?> signInWithGoogle() async {
 64:     try {
 65:       return await _authService.signInWithGoogle();
 66:     } catch (e, stackTrace) {
 67:       _logger.severe(
 68:           'Error signing in with Google in repository', e, stackTrace);
 69:       rethrow;
 70:     }
 71:   }
 72: 
 73:   Future<UserModel?> signInWithEmailPassword(
 74:       String email, String password) async {
 75:     try {
 76:       return await _authService.signInWithEmailPassword(email, password);
 77:     } catch (e, stackTrace) {
 78:       _logger.severe(
 79:           'Error signing in with email/password in repository', e, stackTrace);
 80:       rethrow;
 81:     }
 82:   }
 83: 
 84:   Future<UserModel?> registerWithEmailPassword(
 85:     String email,
 86:     String password,
 87:     String displayName,
 88:   ) async {
 89:     try {
 90:       return await _authService.registerWithEmailPassword(
 91:         email,
 92:         password,
 93:         displayName,
 94:       );
 95:     } catch (e, stackTrace) {
 96:       _logger.severe(
 97:           'Error registering with email/password in repository', e, stackTrace);
 98:       rethrow;
 99:     }
100:   }
101: 
102:   Future<UserModel?> signInAsGuest() async {
103:     try {
104:       return await _authService.signInAsGuest();
105:     } catch (e, stackTrace) {
106:       _logger.severe('Error signing in as guest in repository', e, stackTrace);
107:       rethrow;
108:     }
109:   }
110: 
111:   Future<void> linkWithGoogle() async {
112:     await _authService.linkWithGoogle();
113:   }
114: 
115:   Future<void> linkWithEmailPassword(String email, String password) async {
116:     await _authService.linkWithEmailPassword(email, password);
117:   }
118: 
119:   Future<void> signOut() async {
120:     try {
121:       await _authService.signOut();
122:     } catch (e, stackTrace) {
123:       _logger.severe('Error signing out in repository', e, stackTrace);
124:       rethrow;
125:     }
126:   }
127: 
128:   Future<void> sendEmailVerification() async {
129:     try {
130:       await _authService.sendEmailVerification();
131:     } catch (e, stackTrace) {
132:       _logger.severe(
133:           'Error sending email verification in repository', e, stackTrace);
134:       rethrow;
135:     }
136:   }
137: 
138:   Future<void> checkEmailVerification() async {
139:     try {
140:       await _authService.checkEmailVerification();
141:     } catch (e, stackTrace) {
142:       _logger.severe(
143:           'Error checking email verification in repository', e, stackTrace);
144:       rethrow;
145:     }
146:   }
147: 
148: }
</file>

<file path="lib/features/auth/services/auth_service.dart">
  1: // lib/features/auth/services/auth_service.dart
  2: 
  3: import 'package:firebase_auth/firebase_auth.dart';
  4: import 'package:google_sign_in/google_sign_in.dart';
  5: import 'package:cloud_firestore/cloud_firestore.dart';
  6: import 'package:connectivity_plus/connectivity_plus.dart';
  7: import 'package:firebase_app_check/firebase_app_check.dart';
  8: import 'package:flutter/foundation.dart';
  9: import '../../../core/logging/logger_service.dart';
 10: import '../../../models/user_model.dart';
 11: import 'package:shared_preferences/shared_preferences.dart';
 12: import 'dart:async';
 13: import 'dart:convert';
 14: 
 15: class AuthService {
 16:   final FirebaseAuth _auth;
 17:   final GoogleSignIn _googleSignIn;
 18:   final FirebaseFirestore _firestore;
 19:   final LoggerService _logger;
 20: 
 21:   static const String _guestPrefsKey = 'guest_session';
 22:   static const Duration _timeout = Duration(seconds: 30);
 23: 
 24:   AuthService({
 25:     FirebaseAuth? auth,
 26:     GoogleSignIn? googleSignIn,
 27:     FirebaseFirestore? firestore,
 28:     LoggerService? logger,
 29:   })  : _auth = auth ?? FirebaseAuth.instance,
 30:         _googleSignIn = googleSignIn ??
 31:             GoogleSignIn(
 32:               scopes: ['email'],
 33:               signInOption: SignInOption.standard,
 34:             ),
 35:         _firestore = firestore ?? FirebaseFirestore.instance,
 36:         _logger = logger ?? LoggerService();
 37: 
 38:   Stream<User?> get authStateChanges => _auth.authStateChanges();
 39:   User? get currentUser => _auth.currentUser;
 40: 
 41:   Future<UserModel?> getCurrentUser() async {
 42:     try {
 43:       // Check for guest session first
 44:       final prefs = await SharedPreferences.getInstance();
 45:       final guestData = prefs.getString(_guestPrefsKey);
 46:       if (guestData != null) {
 47:         return UserModel.fromJson(guestData);
 48:       }
 49: 
 50:       // Check for authenticated user
 51:       final User? user = _auth.currentUser;
 52:       if (user == null) return null;
 53: 
 54:       final doc = await _firestore.collection('users').doc(user.uid).get();
 55:       if (doc.exists) {
 56:         return UserModel.fromFirestore(doc);
 57:       }
 58:       return null;
 59:     } catch (e, stackTrace) {
 60:       _logger.severe('Error getting current user', e, stackTrace);
 61:       return null;
 62:     }
 63:   }
 64: 
 65:   Future<UserModel?> signInWithGoogle() async {
 66:     try {
 67:       await _verifyConnectivityAndAppCheck();
 68: 
 69:       // Sign out of any existing Google sessions
 70:       await _googleSignIn.signOut();
 71: 
 72:       final GoogleSignInAccount? googleUser = await _googleSignIn.signIn();
 73:       if (googleUser == null) {
 74:         _logger.warning('Google sign in cancelled by user');
 75:         return null;
 76:       }
 77: 
 78:       final GoogleSignInAuthentication googleAuth =
 79:           await googleUser.authentication;
 80:       final credential = GoogleAuthProvider.credential(
 81:         accessToken: googleAuth.accessToken,
 82:         idToken: googleAuth.idToken,
 83:       );
 84: 
 85:       try {
 86:         final userCredential = await _auth.signInWithCredential(credential);
 87:         return await _createOrUpdateUser(userCredential.user!);
 88:       } on FirebaseAuthException catch (e) {
 89:         if (e.code == 'account-exists-with-different-credential') {
 90:           throw FirebaseAuthException(
 91:             code: 'account-exists',
 92:             message:
 93:                 'An account already exists with this email. Please sign in with your original method.',
 94:           );
 95:         }
 96:         rethrow;
 97:       }
 98:     } catch (e) {
 99:       _logger.severe('Error signing in with Google', e);
100:       rethrow;
101:     }
102:   }
103: 
104:   Future<UserModel?> signInWithEmailPassword(
105:       String email, String password) async {
106:     try {
107:       await _verifyConnectivityAndAppCheck();
108: 
109:       final userCredential = await _auth
110:           .signInWithEmailAndPassword(
111:             email: email.trim(),
112:             password: password,
113:           )
114:           .timeout(_timeout);
115: 
116:       final user = userCredential.user;
117:       if (user == null) {
118:         throw FirebaseAuthException(
119:           code: 'null-user',
120:           message: 'Failed to get user details from Firebase',
121:         );
122:       }
123: 
124:       await _clearGuestSession();
125:       return await _createOrUpdateUser(user);
126:     } on FirebaseAuthException catch (e) {
127:       _logger.severe('Firebase Auth Error: ${e.message}', e);
128:       rethrow;
129:     } catch (e) {
130:       _logger.severe('Error signing in with email/password', e);
131:       throw FirebaseAuthException(
132:         code: 'unknown',
133:         message: 'Authentication failed: ${e.toString()}',
134:       );
135:     }
136:   }
137: 
138:   Future<UserModel?> signInAsGuest() async {
139:     try {
140:       _logger.info('Creating guest session');
141: 
142:       final timestamp = DateTime.now();
143:       final guestId = 'guest_${timestamp.millisecondsSinceEpoch}';
144: 
145:       final guestUser = UserModel(
146:         id: guestId,
147:         displayName: 'Guest User',
148:         isGuest: true,
149:         isEmailVerified: false,
150:         createdAt: timestamp,
151:         lastLoginAt: timestamp,
152:       );
153: 
154:       final prefs = await SharedPreferences.getInstance();
155:       final guestData = {
156:         ...guestUser.toMap(),
157:         'createdAt': guestUser.createdAt.toIso8601String(),
158:         'lastLoginAt': guestUser.lastLoginAt.toIso8601String(),
159:       };
160:       await prefs.setString(_guestPrefsKey, jsonEncode(guestData));
161: 
162:       _logger.info('Guest session created successfully with ID: $guestId');
163:       return guestUser;
164:     } catch (e, stackTrace) {
165:       _logger.severe('Error creating guest session', e, stackTrace);
166:       throw FirebaseAuthException(
167:         code: 'guest-session-failed',
168:         message: 'Failed to create guest session: ${e.toString()}',
169:       );
170:     }
171:   }
172: 
173:   Future<bool> isGuestSession() async {
174:     try {
175:       final prefs = await SharedPreferences.getInstance();
176:       return prefs.containsKey(_guestPrefsKey);
177:     } catch (e, stackTrace) {
178:       _logger.severe('Error checking guest session', e, stackTrace);
179:       return false;
180:     }
181:   }
182: 
183:   Future<void> _clearGuestSession() async {
184:     try {
185:       final prefs = await SharedPreferences.getInstance();
186:       await prefs.remove(_guestPrefsKey);
187:     } catch (e, stackTrace) {
188:       _logger.severe('Error clearing guest session', e, stackTrace);
189:     }
190:   }
191: 
192:   Future<UserModel?> registerWithEmailPassword(
193:     String email,
194:     String password,
195:     String displayName,
196:   ) async {
197:     try {
198:       await _verifyConnectivityAndAppCheck();
199: 
200:       try {
201:         final userCredential = await _auth
202:             .createUserWithEmailAndPassword(
203:               email: email.trim(),
204:               password: password,
205:             )
206:             .timeout(_timeout);
207: 
208:         final user = userCredential.user;
209:         if (user == null) {
210:           throw FirebaseAuthException(
211:             code: 'null-user',
212:             message: 'Failed to create user account',
213:           );
214:         }
215: 
216:         await user.updateDisplayName(displayName.trim());
217:         await user.sendEmailVerification();
218:         await _clearGuestSession();
219: 
220:         return await _createOrUpdateUser(user);
221:       } on FirebaseAuthException catch (e) {
222:         if (e.code == 'email-already-in-use') {
223:           _logger.warning('Email already in use: $email');
224:           return null;
225:         }
226:         rethrow;
227:       }
228:     } catch (e) {
229:       _logger.severe('Error registering with email/password', e);
230:       rethrow;
231:     }
232:   }
233: 
234:   Future<void> signOut() async {
235:     try {
236:       if (await isGuestSession()) {
237:         await _clearGuestSession();
238:         _logger.info('Guest session cleared');
239:         return;
240:       }
241: 
242:       await Future.wait([
243:         _auth.signOut(),
244:         _googleSignIn.signOut(),
245:       ]);
246:       _logger.info('User signed out successfully');
247:     } catch (e, stackTrace) {
248:       _logger.severe('Error signing out', e, stackTrace);
249:       rethrow;
250:     }
251:   }
252: 
253:   Future<UserModel> _createOrUpdateUser(User user) async {
254:     final userDoc = _firestore.collection('users').doc(user.uid);
255: 
256:     final userData = UserModel(
257:       id: user.uid,
258:       email: user.email,
259:       displayName: user.displayName ?? 'User ${user.uid.substring(0, 4)}',
260:       isGuest: false,
261:       isEmailVerified: user.emailVerified,
262:       lastLoginAt: DateTime.now(),
263:       createdAt: DateTime.now(),
264:     );
265: 
266:     try {
267:       final doc = await userDoc.get();
268:       if (!doc.exists) {
269:         await userDoc.set(userData.toMap());
270:         _logger.info('Created new user document for ${user.uid}');
271:       } else {
272:         await userDoc.update({
273:           'lastLoginAt': Timestamp.fromDate(DateTime.now()),
274:           'email': user.email,
275:           'displayName': user.displayName,
276:           'isEmailVerified': user.emailVerified,
277:         });
278:         _logger.info('Updated user document for ${user.uid}');
279:       }
280: 
281:       return userData;
282:     } catch (e, stackTrace) {
283:       _logger.severe('Error creating/updating user', e, stackTrace);
284:       throw FirebaseAuthException(
285:         code: 'user-update-failed',
286:         message: 'Failed to update user data: ${e.toString()}',
287:       );
288:     }
289:   }
290: 
291:   Future<void> sendEmailVerification() async {
292:     try {
293:       final user = _auth.currentUser;
294:       if (user != null && !user.emailVerified) {
295:         await user.sendEmailVerification().timeout(_timeout);
296:         _logger.info('Verification email sent to ${user.email}');
297:       }
298:     } catch (e, stackTrace) {
299:       _logger.severe('Error sending email verification', e, stackTrace);
300:       rethrow;
301:     }
302:   }
303: 
304:   Future<void> checkEmailVerification() async {
305:     try {
306:       final user = _auth.currentUser;
307:       if (user != null) {
308:         await user.reload().timeout(_timeout);
309:         _logger.info('Email verification status: ${user.emailVerified}');
310:       }
311:     } catch (e, stackTrace) {
312:       _logger.severe('Error checking email verification', e, stackTrace);
313:       rethrow;
314:     }
315:   }
316: 
317:   Future<void> linkWithGoogle() async {
318:     try {
319:       final user = _auth.currentUser;
320:       if (user == null) {
321:         throw FirebaseAuthException(
322:           code: 'no-user',
323:           message: 'No user is currently signed in',
324:         );
325:       }
326: 
327:       final googleUser = await _googleSignIn.signIn();
328:       if (googleUser == null) {
329:         _logger.info('Google sign in cancelled');
330:         return;
331:       }
332: 
333:       final googleAuth = await googleUser.authentication;
334:       final credential = GoogleAuthProvider.credential(
335:         accessToken: googleAuth.accessToken,
336:         idToken: googleAuth.idToken,
337:       );
338: 
339:       try {
340:         await user.linkWithCredential(credential);
341:         _logger.info('Successfully linked Google account');
342:       } on FirebaseAuthException catch (e) {
343:         if (e.code == 'credential-already-in-use') {
344:           throw FirebaseAuthException(
345:             code: 'account-exists',
346:             message: 'This Google account is already linked to another user',
347:           );
348:         }
349:         rethrow;
350:       }
351:     } catch (e, stackTrace) {
352:       _logger.severe('Error linking Google account', e, stackTrace);
353:       rethrow;
354:     }
355:   }
356: 
357:   Future<void> linkWithEmailPassword(String email, String password) async {
358:     try {
359:       final user = _auth.currentUser;
360:       if (user == null) {
361:         throw FirebaseAuthException(
362:           code: 'no-user',
363:           message: 'No user is currently signed in',
364:         );
365:       }
366: 
367:       final credential = EmailAuthProvider.credential(
368:         email: email,
369:         password: password,
370:       );
371: 
372:       try {
373:         await user.linkWithCredential(credential);
374:         _logger.info('Successfully linked email/password account');
375:       } on FirebaseAuthException catch (e) {
376:         if (e.code == 'email-already-in-use') {
377:           throw FirebaseAuthException(
378:             code: 'account-exists',
379:             message: 'This email is already in use by another account',
380:           );
381:         }
382:         rethrow;
383:       }
384:     } catch (e, stackTrace) {
385:       _logger.severe('Error linking email/password account', e, stackTrace);
386:       rethrow;
387:     }
388:   }
389: 
390:   Future<void> _verifyConnectivityAndAppCheck() async {
391:     final connectivityResult = await Connectivity().checkConnectivity();
392:     if (connectivityResult.contains(ConnectivityResult.none)) {
393:       throw FirebaseAuthException(
394:         code: 'no-connection',
395:         message: 'No internet connection available',
396:       );
397:     }
398: 
399:     if (!kDebugMode) {
400:       try {
401:         final token =
402:             await FirebaseAppCheck.instance.getToken(true).timeout(_timeout);
403:         if (token == null) {
404:           throw FirebaseAuthException(
405:             code: 'app-check-failed',
406:             message: 'Failed to verify app authenticity',
407:           );
408:         }
409:       } catch (e) {
410:         _logger.severe('App Check verification failed', e);
411:         throw FirebaseAuthException(
412:           code: 'app-check-failed',
413:           message: 'Failed to verify app authenticity',
414:         );
415:       }
416:     }
417:   }
418: 
419: String getReadableAuthError(FirebaseAuthException e) {
420:     switch (e.code) {
421:       case 'invalid-credential':
422:         return 'Invalid email or password. Please try again.';
423:       case 'user-disabled':
424:         return 'This account has been disabled. Please contact support.';
425:       case 'user-not-found':
426:         return 'No account found with this email. Please check your email or create an account.';
427:       case 'wrong-password':
428:         return 'Incorrect password. Please try again or use "Forgot Password?".';
429:       case 'invalid-email':
430:         return 'Please enter a valid email address.';
431:       case 'email-already-in-use':
432:         return 'An account already exists with this email. Please sign in or use a different email.';
433:       case 'operation-not-allowed':
434:         return 'This sign-in method is not enabled. Please contact support.';
435:       case 'weak-password':
436:         return 'Please choose a stronger password.';
437:       case 'network-request-failed':
438:         return 'Network error. Please check your connection and try again.';
439:       case 'too-many-requests':
440:         return 'Too many attempts. Please try again later.';
441:       default:
442:         return e.message ?? 'An error occurred. Please try again.';
443:     }
444:   }
445: 
446: }
</file>

<file path="lib/features/cards/models/card_extended_data.dart">
 1: import 'package:hive/hive.dart';
 2: 
 3: part 'card_extended_data.g.dart';
 4: 
 5: @HiveType(typeId: 2)
 6: class CardExtendedData {
 7:   @HiveField(0)
 8:   final String displayName;
 9: 
10:   @HiveField(1)
11:   final String name;
12: 
13:   @HiveField(2)
14:   final String value;
15: 
16:   const CardExtendedData({
17:     required this.displayName,
18:     required this.name,
19:     required this.value,
20:   });
21: 
22:   factory CardExtendedData.fromMap(Map<String, dynamic> map) {
23:     return CardExtendedData(
24:       displayName: map['displayName'] as String,
25:       name: map['name'] as String,
26:       value: map['value'] as String,
27:     );
28:   }
29: 
30:   Map<String, dynamic> toMap() {
31:     return {
32:       'displayName': displayName,
33:       'name': name,
34:       'value': value,
35:     };
36:   }
37: 
38:   CardExtendedData copyWith({
39:     String? displayName,
40:     String? name,
41:     String? value,
42:   }) {
43:     return CardExtendedData(
44:       displayName: displayName ?? this.displayName,
45:       name: name ?? this.name,
46:       value: value ?? this.value,
47:     );
48:   }
49: 
50:   @override
51:   String toString() {
52:     return 'CardExtendedData(displayName: $displayName, name: $name, value: $value)';
53:   }
54: }
</file>

<file path="lib/features/cards/models/card_filter_options.dart">
 1: enum CardSortOption {
 2:   nameAsc,
 3:   nameDesc,
 4:   costAsc,
 5:   costDesc,
 6:   powerAsc,
 7:   powerDesc,
 8:   setNumber,
 9:   releaseDate
10: }
11: 
12: class CardFilterOptions {
13:   final List<String>? elements;
14:   final String? cardType;
15:   final List<String>? costs;
16:   final List<String>? rarities;
17:   final String? job;
18:   final String? category;
19:   final List<String>? opus;
20:   final String? powerRange; // e.g., "1000-5000"
21:   final CardSortOption sortOption;
22:   final bool ascending;
23: 
24:   const CardFilterOptions({
25:     this.elements,
26:     this.cardType,
27:     this.costs,
28:     this.rarities,
29:     this.job,
30:     this.category,
31:     this.opus,
32:     this.powerRange,
33:     this.sortOption = CardSortOption.setNumber,
34:     this.ascending = true,
35:   });
36: 
37:   CardFilterOptions copyWith({
38:     List<String>? elements,
39:     String? cardType,
40:     List<String>? costs,
41:     List<String>? rarities,
42:     String? job,
43:     String? category,
44:     List<String>? opus,
45:     String? powerRange,
46:     CardSortOption? sortOption,
47:     bool? ascending,
48:   }) {
49:     return CardFilterOptions(
50:       elements: elements ?? this.elements,
51:       cardType: cardType ?? this.cardType,
52:       costs: costs ?? this.costs,
53:       rarities: rarities ?? this.rarities,
54:       job: job ?? this.job,
55:       category: category ?? this.category,
56:       opus: opus ?? this.opus,
57:       powerRange: powerRange ?? this.powerRange,
58:       sortOption: sortOption ?? this.sortOption,
59:       ascending: ascending ?? this.ascending,
60:     );
61:   }
62: 
63:   Map<String, dynamic> toJson() {
64:     return {
65:       'elements': elements,
66:       'cardType': cardType,
67:       'costs': costs,
68:       'rarities': rarities,
69:       'job': job,
70:       'category': category,
71:       'opus': opus,
72:       'powerRange': powerRange,
73:       'sortOption': sortOption.index,
74:       'ascending': ascending,
75:     };
76:   }
77: 
78:   factory CardFilterOptions.fromJson(Map<String, dynamic> json) {
79:     return CardFilterOptions(
80:       elements: (json['elements'] as List?)?.cast<String>(),
81:       cardType: json['cardType'] as String?,
82:       costs: (json['costs'] as List?)?.cast<String>(),
83:       rarities: (json['rarities'] as List?)?.cast<String>(),
84:       job: json['job'] as String?,
85:       category: json['category'] as String?,
86:       opus: (json['opus'] as List?)?.cast<String>(),
87:       powerRange: json['powerRange'] as String?,
88:       sortOption: CardSortOption.values[json['sortOption'] as int],
89:       ascending: json['ascending'] as bool,
90:     );
91:   }
92: }
</file>

<file path="lib/features/cards/models/card_image_metadata.dart">
 1: import 'package:hive/hive.dart';
 2: import 'package:cloud_firestore/cloud_firestore.dart';
 3: 
 4: part 'card_image_metadata.g.dart';
 5: 
 6: @HiveType(typeId: 3)
 7: class CardImageMetadata {
 8:   @HiveField(0)
 9:   final String contentType;
10: 
11:   @HiveField(1)
12:   final String hash;
13: 
14:   @HiveField(2)
15:   final int highResSize;
16: 
17:   @HiveField(3)
18:   final int lowResSize;
19: 
20:   @HiveField(4)
21:   final int originalSize;
22: 
23:   @HiveField(5)
24:   final int size;
25: 
26:   @HiveField(6)
27:   final DateTime updated;
28: 
29:   const CardImageMetadata({
30:     required this.contentType,
31:     required this.hash,
32:     required this.highResSize,
33:     required this.lowResSize,
34:     required this.originalSize,
35:     required this.size,
36:     required this.updated,
37:   });
38: 
39:   factory CardImageMetadata.fromMap(Map<String, dynamic> map) {
40:     return CardImageMetadata(
41:       contentType: map['contentType'] as String,
42:       hash: map['hash'] as String,
43:       highResSize: map['highResSize'] as int,
44:       lowResSize: map['lowResSize'] as int,
45:       originalSize: map['originalSize'] as int,
46:       size: map['size'] as int,
47:       updated: (map['updated'] as Timestamp).toDate(),
48:     );
49:   }
50: 
51:   Map<String, dynamic> toMap() {
52:     return {
53:       'contentType': contentType,
54:       'hash': hash,
55:       'highResSize': highResSize,
56:       'lowResSize': lowResSize,
57:       'originalSize': originalSize,
58:       'size': size,
59:       'updated': Timestamp.fromDate(updated),
60:     };
61:   }
62: 
63:   CardImageMetadata copyWith({
64:     String? contentType,
65:     String? hash,
66:     int? highResSize,
67:     int? lowResSize,
68:     int? originalSize,
69:     int? size,
70:     DateTime? updated,
71:   }) {
72:     return CardImageMetadata(
73:       contentType: contentType ?? this.contentType,
74:       hash: hash ?? this.hash,
75:       highResSize: highResSize ?? this.highResSize,
76:       lowResSize: lowResSize ?? this.lowResSize,
77:       originalSize: originalSize ?? this.originalSize,
78:       size: size ?? this.size,
79:       updated: updated ?? this.updated,
80:     );
81:   }
82: 
83:   @override
84:   String toString() {
85:     return 'CardImageMetadata(contentType: $contentType, hash: $hash, highResSize: $highResSize, lowResSize: $lowResSize, originalSize: $originalSize, size: $size, updated: $updated)';
86:   }
87: }
</file>

<file path="lib/features/cards/models/fftcg_card.dart">
  1: import 'package:cloud_firestore/cloud_firestore.dart';
  2: import 'package:hive/hive.dart';
  3: import '../../../core/models/sync_status.dart';
  4: import 'card_image_metadata.dart';
  5: import 'card_extended_data.dart';
  6: 
  7: part 'fftcg_card.g.dart';
  8: 
  9: @HiveType(typeId: 1)
 10: class FFTCGCard extends HiveObject {
 11:   @HiveField(0)
 12:   final int categoryId;
 13: 
 14:   @HiveField(1)
 15:   final String cleanName;
 16: 
 17:   @HiveField(2)
 18:   final List<CardExtendedData> extendedData;
 19: 
 20:   @HiveField(3)
 21:   final String groupHash;
 22: 
 23:   @HiveField(4)
 24:   final int groupId;
 25: 
 26:   @HiveField(5)
 27:   final String highResUrl;
 28: 
 29:   @HiveField(6)
 30:   final int imageCount;
 31: 
 32:   @HiveField(7)
 33:   final CardImageMetadata imageMetadata;
 34: 
 35:   @HiveField(8)
 36:   final DateTime lastUpdated;
 37: 
 38:   @HiveField(9)
 39:   final String lowResUrl;
 40: 
 41:   @HiveField(10)
 42:   final String? modifiedOn;
 43: 
 44:   @HiveField(11)
 45:   final String name;
 46: 
 47:   @HiveField(12)
 48:   final String originalUrl;
 49: 
 50:   @HiveField(13)
 51:   final bool isPresale;
 52: 
 53:   @HiveField(14)
 54:   final int productId;
 55: 
 56:   @HiveField(15)
 57:   final String url;
 58: 
 59:   // Sync-related fields
 60:   @HiveField(16)
 61:   SyncStatus syncStatus;
 62: 
 63:   @HiveField(17)
 64:   DateTime? lastModifiedLocally;
 65: 
 66:   // Convenience getters for common card properties (not stored in Hive directly)
 67:   String? get cardNumber => _getExtendedValue('Number');
 68:   String? get description => _getExtendedValue('Description');
 69:   String? get cardType => _getExtendedValue('CardType');
 70:   List<String> get elements => _getExtendedValue('Element')?.split(',') ?? [];
 71:   String? get cost => _getExtendedValue('Cost');
 72:   String? get power => _getExtendedValue('Power');
 73:   String? get job => _getExtendedValue('Job');
 74:   String? get category => _getExtendedValue('Category');
 75:   String? get rarity => _getExtendedValue('Rarity');
 76: 
 77:   FFTCGCard({
 78:     required this.categoryId,
 79:     required this.cleanName,
 80:     required this.extendedData,
 81:     required this.groupHash,
 82:     required this.groupId,
 83:     required this.highResUrl,
 84:     required this.imageCount,
 85:     required this.imageMetadata,
 86:     required this.lastUpdated,
 87:     required this.lowResUrl,
 88:     required this.name,
 89:     required this.originalUrl,
 90:     required this.isPresale,
 91:     required this.productId,
 92:     required this.url,
 93:     this.modifiedOn,
 94:     this.syncStatus = SyncStatus.synced,
 95:     this.lastModifiedLocally,
 96:   });
 97: 
 98:   String? _getExtendedValue(String name) {
 99:     return extendedData
100:         .firstWhere(
101:           (data) => data.name == name,
102:           orElse: () => const CardExtendedData(
103:             displayName: '',
104:             name: '',
105:             value: '',
106:           ),
107:         )
108:         .value;
109:   }
110: 
111:   factory FFTCGCard.fromFirestore(DocumentSnapshot doc) {
112:     final data = doc.data() as Map<String, dynamic>;
113:     return FFTCGCard(
114:       categoryId: data['categoryId'] as int,
115:       cleanName: data['cleanName'] as String,
116:       extendedData: (data['extendedData'] as List<dynamic>)
117:           .map((e) => CardExtendedData.fromMap(e as Map<String, dynamic>))
118:           .toList(),
119:       groupHash: data['groupHash'] as String,
120:       groupId: data['groupId'] as int,
121:       highResUrl: data['highResUrl'] as String,
122:       imageCount: data['imageCount'] as int,
123:       imageMetadata: CardImageMetadata.fromMap(
124:         data['imageMetadata'] as Map<String, dynamic>,
125:       ),
126:       lastUpdated: (data['lastUpdated'] as Timestamp).toDate(),
127:       lowResUrl: data['lowResUrl'] as String,
128:       modifiedOn: data['modifiedOn'] as String?,
129:       name: data['name'] as String,
130:       originalUrl: data['originalUrl'] as String,
131:       isPresale:
132:           (data['presaleInfo'] as Map<String, dynamic>)['isPresale'] as bool,
133:       productId: data['productId'] as int,
134:       url: data['url'] as String,
135:     );
136:   }
137: 
138:   Map<String, dynamic> toMap() {
139:     return {
140:       'categoryId': categoryId,
141:       'cleanName': cleanName,
142:       'extendedData': extendedData.map((e) => e.toMap()).toList(),
143:       'groupHash': groupHash,
144:       'groupId': groupId,
145:       'highResUrl': highResUrl,
146:       'imageCount': imageCount,
147:       'imageMetadata': imageMetadata.toMap(),
148:       'lastUpdated': Timestamp.fromDate(lastUpdated),
149:       'lowResUrl': lowResUrl,
150:       'modifiedOn': modifiedOn,
151:       'name': name,
152:       'originalUrl': originalUrl,
153:       'presaleInfo': {
154:         'isPresale': isPresale,
155:         'note': null,
156:         'releasedOn': null,
157:       },
158:       'productId': productId,
159:       'url': url,
160:     };
161:   }
162: 
163:   // Sync-related methods
164:   void markForSync() {
165:     syncStatus = SyncStatus.pending;
166:     lastModifiedLocally = DateTime.now();
167:     save(); // Hive save method
168:   }
169: 
170:   void markSynced() {
171:     syncStatus = SyncStatus.synced;
172:     lastModifiedLocally = null;
173:     save();
174:   }
175: 
176:   void markError() {
177:     syncStatus = SyncStatus.error;
178:     save();
179:   }
180: 
181:   // Create a copy of the card with updated sync status
182:   FFTCGCard copyWith({
183:     int? categoryId,
184:     String? cleanName,
185:     List<CardExtendedData>? extendedData,
186:     String? groupHash,
187:     int? groupId,
188:     String? highResUrl,
189:     int? imageCount,
190:     CardImageMetadata? imageMetadata,
191:     DateTime? lastUpdated,
192:     String? lowResUrl,
193:     String? modifiedOn,
194:     String? name,
195:     String? originalUrl,
196:     bool? isPresale,
197:     int? productId,
198:     String? url,
199:     SyncStatus? syncStatus,
200:     DateTime? lastModifiedLocally,
201:   }) {
202:     return FFTCGCard(
203:       categoryId: categoryId ?? this.categoryId,
204:       cleanName: cleanName ?? this.cleanName,
205:       extendedData: extendedData ?? this.extendedData,
206:       groupHash: groupHash ?? this.groupHash,
207:       groupId: groupId ?? this.groupId,
208:       highResUrl: highResUrl ?? this.highResUrl,
209:       imageCount: imageCount ?? this.imageCount,
210:       imageMetadata: imageMetadata ?? this.imageMetadata,
211:       lastUpdated: lastUpdated ?? this.lastUpdated,
212:       lowResUrl: lowResUrl ?? this.lowResUrl,
213:       modifiedOn: modifiedOn ?? this.modifiedOn,
214:       name: name ?? this.name,
215:       originalUrl: originalUrl ?? this.originalUrl,
216:       isPresale: isPresale ?? this.isPresale,
217:       productId: productId ?? this.productId,
218:       url: url ?? this.url,
219:       syncStatus: syncStatus ?? this.syncStatus,
220:       lastModifiedLocally: lastModifiedLocally ?? this.lastModifiedLocally,
221:     );
222:   }
223: }
</file>

<file path="lib/features/cards/presentation/screens/card_detail_screen.dart">
  1: import 'package:cached_network_image/cached_network_image.dart';
  2: import 'package:flutter/material.dart';
  3: import 'package:flutter_riverpod/flutter_riverpod.dart';
  4: import '../../models/fftcg_card.dart';
  5: import '../../providers/card_providers.dart';
  6: import '../../../../core/logging/logger_service.dart';
  7: 
  8: class CardDetailScreen extends ConsumerStatefulWidget {
  9:   final FFTCGCard card;
 10: 
 11:   const CardDetailScreen({
 12:     super.key,
 13:     required this.card,
 14:   });
 15: 
 16:   @override
 17:   ConsumerState<CardDetailScreen> createState() => _CardDetailScreenState();
 18: }
 19: 
 20: class _CardDetailScreenState extends ConsumerState<CardDetailScreen> {
 21:   final _logger = LoggerService();
 22:   bool _isImageExpanded = false;
 23: 
 24:   @override
 25:   void initState() {
 26:     super.initState();
 27:     _logger.info('Viewing card details: ${widget.card.cardNumber}');
 28:     ref.read(cardCacheServiceProvider).addRecentCard(widget.card);
 29:   }
 30: 
 31:   @override
 32:   Widget build(BuildContext context) {
 33:     return Scaffold(
 34:       appBar: AppBar(
 35:         title: Text(widget.card.name),
 36:         actions: [
 37:           IconButton(
 38:             icon: const Icon(Icons.fullscreen),
 39:             onPressed: () {
 40:               setState(() {
 41:                 _isImageExpanded = !_isImageExpanded;
 42:               });
 43:             },
 44:           ),
 45:         ],
 46:       ),
 47:       body: SingleChildScrollView(
 48:         child: Column(
 49:           crossAxisAlignment: CrossAxisAlignment.stretch,
 50:           children: [
 51:             Hero(
 52:               tag: 'card_${widget.card.cardNumber}',
 53:               child: AnimatedContainer(
 54:                 duration: const Duration(milliseconds: 300),
 55:                 height: _isImageExpanded ? 500 : 300,
 56:                 child: CachedNetworkImage(
 57:                   imageUrl: _isImageExpanded
 58:                       ? widget.card.highResUrl
 59:                       : widget.card.lowResUrl,
 60:                   fit: BoxFit.contain,
 61:                   placeholder: (context, url) => const Center(
 62:                     child: CircularProgressIndicator(),
 63:                   ),
 64:                   errorWidget: (context, url, error) => const Center(
 65:                     child: Icon(Icons.error),
 66:                   ),
 67:                 ),
 68:               ),
 69:             ),
 70:             Padding(
 71:               padding: const EdgeInsets.all(16.0),
 72:               child: Column(
 73:                 crossAxisAlignment: CrossAxisAlignment.start,
 74:                 children: [
 75:                   _buildInfoRow('Card Number', widget.card.cardNumber),
 76:                   _buildInfoRow('Type', widget.card.cardType),
 77:                   _buildInfoRow('Cost', widget.card.cost),
 78:                   if (widget.card.power != null)
 79:                     _buildInfoRow('Power', widget.card.power),
 80:                   _buildInfoRow('Job', widget.card.job),
 81:                   _buildInfoRow('Rarity', widget.card.rarity),
 82:                   _buildInfoRow('Category', widget.card.category),
 83:                   const SizedBox(height: 16),
 84:                   if (widget.card.elements.isNotEmpty) ...[
 85:                     Text(
 86:                       'Elements',
 87:                       style: Theme.of(context).textTheme.titleMedium,
 88:                     ),
 89:                     Wrap(
 90:                       spacing: 8,
 91:                       children: widget.card.elements.map((element) {
 92:                         return Chip(
 93:                           label: Text(element),
 94:                         );
 95:                       }).toList(),
 96:                     ),
 97:                   ],
 98:                   const SizedBox(height: 16),
 99:                   if (widget.card.description != null) ...[
100:                     Text(
101:                       'Card Text',
102:                       style: Theme.of(context).textTheme.titleMedium,
103:                     ),
104:                     const SizedBox(height: 8),
105:                     Text(
106:                       widget.card.description!,
107:                       style: Theme.of(context).textTheme.bodyMedium,
108:                     ),
109:                   ],
110:                 ],
111:               ),
112:             ),
113:           ],
114:         ),
115:       ),
116:     );
117:   }
118: 
119:   Widget _buildInfoRow(String label, String? value) {
120:     if (value == null || value.isEmpty) return const SizedBox.shrink();
121: 
122:     return Padding(
123:       padding: const EdgeInsets.symmetric(vertical: 4.0),
124:       child: Row(
125:         crossAxisAlignment: CrossAxisAlignment.start,
126:         children: [
127:           SizedBox(
128:             width: 100,
129:             child: Text(
130:               label,
131:               style: Theme.of(context).textTheme.titleSmall,
132:             ),
133:           ),
134:           Expanded(
135:             child: Text(
136:               value,
137:               style: Theme.of(context).textTheme.bodyMedium,
138:             ),
139:           ),
140:         ],
141:       ),
142:     );
143:   }
144: }
</file>

<file path="lib/features/cards/presentation/screens/cards_screen.dart">
  1: import 'package:flutter/material.dart';
  2: import 'package:flutter_riverpod/flutter_riverpod.dart';
  3: import '../../../auth/providers/auth_providers.dart';
  4: import '../../providers/card_providers.dart';
  5: import '../../models/card_filter_options.dart';
  6: import '../widgets/card_grid_item.dart';
  7: import '../widgets/card_list_item.dart';
  8: import '../widgets/filter_bottom_sheet.dart';
  9: import '../widgets/sort_menu_button.dart';
 10: import '../widgets/search_bar_widget.dart';
 11: import '../../../../core/logging/logger_service.dart';
 12: import '../../providers/card_state.dart';
 13: import '../../../settings/presentation/screens/offline_management_screen.dart';
 14: import '../../../../core/presentation/widgets/app_drawer.dart';
 15: 
 16: class CardsScreen extends ConsumerStatefulWidget {
 17:   final VoidCallback? handleLogout;
 18: 
 19:   const CardsScreen({
 20:     super.key,
 21:     this.handleLogout,
 22:   });
 23: 
 24:   @override
 25:   ConsumerState<CardsScreen> createState() => _CardsScreenState();
 26: }
 27: 
 28: class _CardsScreenState extends ConsumerState<CardsScreen> {
 29:   final _logger = LoggerService();
 30:   final _scrollController = ScrollController();
 31: 
 32:   @override
 33:   void initState() {
 34:     super.initState();
 35:     _logger.info('Cards screen initialized');
 36:   }
 37: 
 38:   @override
 39:   void dispose() {
 40:     _scrollController.dispose();
 41:     super.dispose();
 42:   }
 43: 
 44:   void _showFilterBottomSheet() {
 45:     final currentFilters = ref.read(cardNotifierProvider).filterOptions ??
 46:         const CardFilterOptions();
 47: 
 48:     showModalBottomSheet(
 49:       context: context,
 50:       isScrollControlled: true,
 51:       backgroundColor: Colors.transparent,
 52:       builder: (context) => FilterBottomSheet(
 53:         currentFilters: currentFilters,
 54:         onFilterChanged: (filters) {
 55:           ref.read(cardNotifierProvider.notifier).updateFilters(filters);
 56:         },
 57:       ),
 58:     );
 59:   }
 60: 
 61:   @override
 62:   Widget build(BuildContext context) {
 63:     final cardState = ref.watch(cardNotifierProvider);
 64:     final user = ref.watch(currentUserProvider);
 65: 
 66:     return Scaffold(
 67:       appBar: AppBar(
 68:         title: const Text('Card Database'),
 69:         actions: [
 70:           const SortMenuButton(),
 71:           IconButton(
 72:             icon: Icon(cardState.isGridView ? Icons.list : Icons.grid_view),
 73:             onPressed: () {
 74:               ref.read(cardNotifierProvider.notifier).toggleViewMode();
 75:             },
 76:           ),
 77:           IconButton(
 78:             icon: const Icon(Icons.filter_list),
 79:             onPressed: _showFilterBottomSheet,
 80:           ),
 81:           PopupMenuButton(
 82:             icon: const Icon(Icons.more_vert),
 83:             onSelected: (value) {
 84:               switch (value) {
 85:                 case 'offline':
 86:                   Navigator.push(
 87:                     context,
 88:                     MaterialPageRoute(
 89:                       builder: (context) => const OfflineManagementScreen(),
 90:                     ),
 91:                   );
 92:                   break;
 93:                 case 'logout':
 94:                   if (widget.handleLogout != null) {
 95:                     widget.handleLogout!();
 96:                   }
 97:                   break;
 98:               }
 99:             },
100:             itemBuilder: (context) => [
101:               const PopupMenuItem(
102:                 value: 'offline',
103:                 child: Row(
104:                   children: [
105:                     Icon(Icons.offline_bolt),
106:                     SizedBox(width: 8),
107:                     Text('Offline Management'),
108:                   ],
109:                 ),
110:               ),
111:               if (widget.handleLogout != null)
112:                 const PopupMenuItem(
113:                   value: 'logout',
114:                   child: Row(
115:                     children: [
116:                       Icon(Icons.logout),
117:                       SizedBox(width: 8),
118:                       Text('Logout'),
119:                     ],
120:                   ),
121:                 ),
122:             ],
123:           ),
124:         ],
125:         bottom: PreferredSize(
126:           preferredSize: const Size.fromHeight(80),
127:           child: Column(
128:             children: [
129:               const CardSearchBar(),
130:               if (user != null && !user.isGuest)
131:                 Padding(
132:                   padding: const EdgeInsets.only(bottom: 8.0),
133:                   child: Text(
134:                     'Welcome, ${user.displayName ?? 'User'}',
135:                     style: Theme.of(context).textTheme.bodyMedium,
136:                   ),
137:                 ),
138:             ],
139:           ),
140:         ),
141:       ),
142:       drawer: const AppDrawer(currentRoute: '/cards'),
143:       body: RefreshIndicator(
144:         onRefresh: () => ref.read(cardNotifierProvider.notifier).refreshCards(),
145:         child: switch (cardState.status) {
146:           CardLoadingStatus.loading => const Center(
147:               child: CircularProgressIndicator(),
148:             ),
149:           CardLoadingStatus.error => Center(
150:               child: Column(
151:                 mainAxisAlignment: MainAxisAlignment.center,
152:                 children: [
153:                   Text(cardState.errorMessage ?? 'An error occurred'),
154:                   const SizedBox(height: 16),
155:                   ElevatedButton(
156:                     onPressed: () =>
157:                         ref.read(cardNotifierProvider.notifier).refreshCards(),
158:                     child: const Text('Retry'),
159:                   ),
160:                 ],
161:               ),
162:             ),
163:           _ => cardState.cards.isEmpty
164:               ? const Center(child: Text('No cards found'))
165:               : cardState.isGridView
166:                   ? GridView.builder(
167:                       controller: _scrollController,
168:                       padding: const EdgeInsets.all(8),
169:                       gridDelegate:
170:                           const SliverGridDelegateWithFixedCrossAxisCount(
171:                         crossAxisCount: 2,
172:                         childAspectRatio: 0.7,
173:                         crossAxisSpacing: 8,
174:                         mainAxisSpacing: 8,
175:                       ),
176:                       itemCount: cardState.cards.length,
177:                       itemBuilder: (context, index) {
178:                         final card = cardState.cards[index];
179:                         return CardGridItem(
180:                           card: card,
181:                           useHighRes: false,
182:                         );
183:                       },
184:                     )
185:                   : ListView.builder(
186:                       controller: _scrollController,
187:                       padding: const EdgeInsets.all(8),
188:                       itemCount: cardState.cards.length,
189:                       itemBuilder: (context, index) {
190:                         final card = cardState.cards[index];
191:                         return CardListItem(
192:                           card: card,
193:                         );
194:                       },
195:                     ),
196:         },
197:       ),
198:     );
199:   }
200: }
</file>

<file path="lib/features/cards/presentation/widgets/card_grid_item.dart">
 1: import 'package:cached_network_image/cached_network_image.dart';
 2: import 'package:flutter/material.dart';
 3: import '../../models/fftcg_card.dart';
 4: import '../screens/card_detail_screen.dart';
 5: 
 6: class CardGridItem extends StatelessWidget {
 7:   final FFTCGCard card;
 8:   final bool useHighRes;
 9: 
10:   const CardGridItem({
11:     super.key,
12:     required this.card,
13:     this.useHighRes = false,
14:   });
15: 
16:   @override
17:   Widget build(BuildContext context) {
18:     return Card(
19:       clipBehavior: Clip.antiAlias,
20:       child: InkWell(
21:         onTap: () {
22:           Navigator.of(context).push(
23:             MaterialPageRoute(
24:               builder: (context) => CardDetailScreen(card: card),
25:             ),
26:           );
27:         },
28:         child: Column(
29:           crossAxisAlignment: CrossAxisAlignment.stretch,
30:           children: [
31:             Expanded(
32:               child: Hero(
33:                 tag: 'card_${card.cardNumber}',
34:                 child: CachedNetworkImage(
35:                   imageUrl: useHighRes ? card.highResUrl : card.lowResUrl,
36:                   fit: BoxFit.contain,
37:                   placeholder: (context, url) => const Center(
38:                     child: CircularProgressIndicator(),
39:                   ),
40:                   errorWidget: (context, url, error) => const Center(
41:                     child: Icon(Icons.error),
42:                   ),
43:                 ),
44:               ),
45:             ),
46:             Padding(
47:               padding: const EdgeInsets.all(8.0),
48:               child: Column(
49:                 crossAxisAlignment: CrossAxisAlignment.start,
50:                 children: [
51:                   Text(
52:                     card.name,
53:                     style: Theme.of(context).textTheme.titleSmall,
54:                     maxLines: 1,
55:                     overflow: TextOverflow.ellipsis,
56:                   ),
57:                   Row(
58:                     mainAxisAlignment: MainAxisAlignment.spaceBetween,
59:                     children: [
60:                       Text(
61:                         card.cardNumber ?? '',
62:                         style: Theme.of(context).textTheme.bodySmall,
63:                       ),
64:                       if (card.cost != null)
65:                         Text(
66:                           'Cost: ${card.cost}',
67:                           style: Theme.of(context).textTheme.bodySmall,
68:                         ),
69:                     ],
70:                   ),
71:                 ],
72:               ),
73:             ),
74:           ],
75:         ),
76:       ),
77:     );
78:   }
79: }
</file>

<file path="lib/features/cards/presentation/widgets/card_list_item.dart">
 1: import 'package:cached_network_image/cached_network_image.dart';
 2: import 'package:flutter/material.dart';
 3: import '../../models/fftcg_card.dart';
 4: import '../screens/card_detail_screen.dart';
 5: 
 6: class CardListItem extends StatelessWidget {
 7:   final FFTCGCard card;
 8: 
 9:   const CardListItem({
10:     super.key,
11:     required this.card,
12:   });
13: 
14:   @override
15:   Widget build(BuildContext context) {
16:     return Card(
17:       child: ListTile(
18:         onTap: () {
19:           Navigator.of(context).push(
20:             MaterialPageRoute(
21:               builder: (context) => CardDetailScreen(card: card),
22:             ),
23:           );
24:         },
25:         leading: Hero(
26:           tag: 'card_${card.cardNumber}',
27:           child: SizedBox(
28:             width: 50,
29:             child: CachedNetworkImage(
30:               imageUrl: card.lowResUrl,
31:               fit: BoxFit.contain,
32:               placeholder: (context, url) => const Center(
33:                 child: CircularProgressIndicator(),
34:               ),
35:               errorWidget: (context, url, error) => const Center(
36:                 child: Icon(Icons.error),
37:               ),
38:             ),
39:           ),
40:         ),
41:         title: Text(card.name),
42:         subtitle: Row(
43:           children: [
44:             Text(card.cardNumber ?? ''),
45:             if (card.elements.isNotEmpty) ...[
46:               const SizedBox(width: 8),
47:               ...card.elements.map(
48:                 (element) => Padding(
49:                   padding: const EdgeInsets.only(right: 4),
50:                   child: Text(
51:                     element,
52:                     style: Theme.of(context).textTheme.bodySmall?.copyWith(
53:                           fontWeight: FontWeight.bold,
54:                         ),
55:                   ),
56:                 ),
57:               ),
58:             ],
59:           ],
60:         ),
61:         trailing: Column(
62:           mainAxisAlignment: MainAxisAlignment.center,
63:           crossAxisAlignment: CrossAxisAlignment.end,
64:           children: [
65:             if (card.cost != null)
66:               Text(
67:                 'Cost: ${card.cost}',
68:                 style: Theme.of(context).textTheme.bodySmall,
69:               ),
70:             if (card.power != null)
71:               Text(
72:                 'Power: ${card.power}',
73:                 style: Theme.of(context).textTheme.bodySmall,
74:               ),
75:           ],
76:         ),
77:       ),
78:     );
79:   }
80: }
</file>

<file path="lib/features/cards/presentation/widgets/filter_bottom_sheet.dart">
  1: import 'package:flutter/material.dart';
  2: import 'package:flutter_riverpod/flutter_riverpod.dart';
  3: import '../../models/card_filter_options.dart';
  4: import '../../providers/card_providers.dart';
  5: 
  6: class FilterBottomSheet extends ConsumerStatefulWidget {
  7:   final CardFilterOptions currentFilters;
  8:   final ValueChanged<CardFilterOptions> onFilterChanged;
  9: 
 10:   const FilterBottomSheet({
 11:     super.key,
 12:     required this.currentFilters,
 13:     required this.onFilterChanged,
 14:   });
 15: 
 16:   @override
 17:   ConsumerState<FilterBottomSheet> createState() => _FilterBottomSheetState();
 18: }
 19: 
 20: class _FilterBottomSheetState extends ConsumerState<FilterBottomSheet> {
 21:   late CardFilterOptions _filters;
 22: 
 23:   @override
 24:   void initState() {
 25:     super.initState();
 26:     _filters = widget.currentFilters;
 27:   }
 28: 
 29:   @override
 30:   Widget build(BuildContext context) {
 31:     final elements = ref.watch(uniqueElementsProvider);
 32:     final cardTypes = ref.watch(uniqueCardTypesProvider);
 33: 
 34:     return DraggableScrollableSheet(
 35:       initialChildSize: 0.9,
 36:       minChildSize: 0.5,
 37:       maxChildSize: 0.9,
 38:       builder: (context, scrollController) {
 39:         return Container(
 40:           decoration: BoxDecoration(
 41:             color: Theme.of(context).scaffoldBackgroundColor,
 42:             borderRadius: const BorderRadius.vertical(top: Radius.circular(16)),
 43:           ),
 44:           child: Column(
 45:             children: [
 46:               Padding(
 47:                 padding: const EdgeInsets.all(8.0),
 48:                 child: Row(
 49:                   mainAxisAlignment: MainAxisAlignment.spaceBetween,
 50:                   children: [
 51:                     TextButton(
 52:                       onPressed: () {
 53:                         setState(() {
 54:                           _filters = const CardFilterOptions();
 55:                         });
 56:                       },
 57:                       child: const Text('Reset'),
 58:                     ),
 59:                     Text(
 60:                       'Filters',
 61:                       style: Theme.of(context).textTheme.titleLarge,
 62:                     ),
 63:                     TextButton(
 64:                       onPressed: () {
 65:                         widget.onFilterChanged(_filters);
 66:                         Navigator.pop(context);
 67:                       },
 68:                       child: const Text('Apply'),
 69:                     ),
 70:                   ],
 71:                 ),
 72:               ),
 73:               const Divider(),
 74:               Expanded(
 75:                 child: ListView(
 76:                   controller: scrollController,
 77:                   padding: const EdgeInsets.all(16),
 78:                   children: [
 79:                     Text(
 80:                       'Elements',
 81:                       style: Theme.of(context).textTheme.titleMedium,
 82:                     ),
 83:                     elements.when(
 84:                       data: (elements) => Wrap(
 85:                         spacing: 8,
 86:                         children: elements.map((element) {
 87:                           return FilterChip(
 88:                             label: Text(element),
 89:                             selected:
 90:                                 _filters.elements?.contains(element) ?? false,
 91:                             onSelected: (selected) {
 92:                               setState(() {
 93:                                 final currentElements =
 94:                                     List<String>.from(_filters.elements ?? []);
 95:                                 if (selected) {
 96:                                   currentElements.add(element);
 97:                                 } else {
 98:                                   currentElements.remove(element);
 99:                                 }
100:                                 _filters = _filters.copyWith(
101:                                   elements: currentElements.isEmpty
102:                                       ? null
103:                                       : currentElements,
104:                                 );
105:                               });
106:                             },
107:                           );
108:                         }).toList(),
109:                       ),
110:                       loading: () => const CircularProgressIndicator(),
111:                       error: (_, __) => const Text('Failed to load elements'),
112:                     ),
113:                     const SizedBox(height: 16),
114:                     Text(
115:                       'Card Type',
116:                       style: Theme.of(context).textTheme.titleMedium,
117:                     ),
118:                     cardTypes.when(
119:                       data: (types) => Wrap(
120:                         spacing: 8,
121:                         children: types.map((type) {
122:                           return ChoiceChip(
123:                             label: Text(type),
124:                             selected: _filters.cardType == type,
125:                             onSelected: (selected) {
126:                               setState(() {
127:                                 _filters = _filters.copyWith(
128:                                   cardType: selected ? type : null,
129:                                 );
130:                               });
131:                             },
132:                           );
133:                         }).toList(),
134:                       ),
135:                       loading: () => const CircularProgressIndicator(),
136:                       error: (_, __) => const Text('Failed to load card types'),
137:                     ),
138:                     const SizedBox(height: 16),
139:                     Text(
140:                       'Cost',
141:                       style: Theme.of(context).textTheme.titleMedium,
142:                     ),
143:                     Wrap(
144:                       spacing: 8,
145:                       children: List.generate(13, (index) {
146:                         final cost = index.toString();
147:                         return FilterChip(
148:                           label: Text(cost),
149:                           selected: _filters.costs?.contains(cost) ?? false,
150:                           onSelected: (selected) {
151:                             setState(() {
152:                               final currentCosts =
153:                                   List<String>.from(_filters.costs ?? []);
154:                               if (selected) {
155:                                 currentCosts.add(cost);
156:                               } else {
157:                                 currentCosts.remove(cost);
158:                               }
159:                               _filters = _filters.copyWith(
160:                                 costs:
161:                                     currentCosts.isEmpty ? null : currentCosts,
162:                               );
163:                             });
164:                           },
165:                         );
166:                       }),
167:                     ),
168:                     // Additional filter sections will be added here
169:                   ],
170:                 ),
171:               ),
172:             ],
173:           ),
174:         );
175:       },
176:     );
177:   }
178: }
</file>

<file path="lib/features/cards/presentation/widgets/search_bar_widget.dart">
  1: import 'dart:async';
  2: import 'package:flutter/material.dart';
  3: import 'package:flutter_riverpod/flutter_riverpod.dart';
  4: import '../../providers/card_providers.dart';
  5: import '../screens/card_detail_screen.dart';
  6: import '../../../../core/logging/logger_service.dart';
  7: import '../../models/fftcg_card.dart';
  8: 
  9: class CardSearchBar extends ConsumerStatefulWidget {
 10:   const CardSearchBar({super.key});
 11: 
 12:   @override
 13:   ConsumerState<CardSearchBar> createState() => _CardSearchBarState();
 14: }
 15: 
 16: class _CardSearchBarState extends ConsumerState<CardSearchBar> {
 17:   final _searchController = TextEditingController();
 18:   final _logger = LoggerService();
 19:   final _debouncer = Debouncer(milliseconds: 500);
 20:   bool _isSearching = false;
 21:   OverlayEntry? _overlayEntry;
 22: 
 23:   @override
 24:   void initState() {
 25:     super.initState();
 26:     _logger.info('Search bar initialized');
 27:   }
 28: 
 29:   @override
 30:   void dispose() {
 31:     _searchController.dispose();
 32:     _debouncer.dispose();
 33:     _removeOverlay();
 34:     super.dispose();
 35:   }
 36: 
 37:   void _onSearchChanged(String query) {
 38:     _debouncer.run(() {
 39:       if (mounted) {
 40:         setState(() => _isSearching = query.isNotEmpty);
 41:         if (query.isNotEmpty) {
 42:           _showSearchResults(query);
 43:         } else {
 44:           _removeOverlay();
 45:         }
 46:       }
 47:     });
 48:   }
 49: 
 50:   void _removeOverlay() {
 51:     _overlayEntry?.remove();
 52:     _overlayEntry = null;
 53:   }
 54: 
 55:   void _showSearchResults(String query) {
 56:     _removeOverlay();
 57: 
 58:     final RenderBox renderBox = context.findRenderObject() as RenderBox;
 59:     final size = renderBox.size;
 60:     final offset = renderBox.localToGlobal(Offset.zero);
 61: 
 62:     _overlayEntry = OverlayEntry(
 63:       builder: (context) => Positioned(
 64:         top: offset.dy + size.height,
 65:         left: offset.dx,
 66:         width: size.width,
 67:         child: Material(
 68:           elevation: 8,
 69:           color: Theme.of(context).scaffoldBackgroundColor,
 70:           child: Container(
 71:             constraints: BoxConstraints(
 72:               maxHeight: MediaQuery.of(context).size.height * 0.4,
 73:             ),
 74:             child: Consumer(
 75:               builder: (context, ref, _) {
 76:                 final searchResults = ref.watch(searchResultsProvider(query));
 77: 
 78:                 return searchResults.when(
 79:                   data: (List<FFTCGCard> cards) {
 80:                     if (cards.isEmpty) {
 81:                       return const ListTile(
 82:                         title: Text('No cards found'),
 83:                       );
 84:                     }
 85: 
 86:                     return ListView.builder(
 87:                       shrinkWrap: true,
 88:                       itemCount: cards.length,
 89:                       itemBuilder: (context, index) {
 90:                         final card = cards[index];
 91:                         return ListTile(
 92:                           leading: SizedBox(
 93:                             width: 40,
 94:                             height: 56,
 95:                             child: Hero(
 96:                               tag: 'search_${card.cardNumber}',
 97:                               child: Image.network(
 98:                                 card.lowResUrl,
 99:                                 fit: BoxFit.contain,
100:                                 errorBuilder: (context, error, stackTrace) {
101:                                   _logger.severe('Error loading card image',
102:                                       error, stackTrace);
103:                                   return const Icon(Icons.error);
104:                                 },
105:                               ),
106:                             ),
107:                           ),
108:                           title: Text(
109:                             card.name,
110:                             maxLines: 1,
111:                             overflow: TextOverflow.ellipsis,
112:                           ),
113:                           subtitle: Text(
114:                             card.cardNumber ?? '',
115:                             maxLines: 1,
116:                           ),
117:                           trailing: card.elements.isNotEmpty
118:                               ? Text(
119:                                   card.elements.first,
120:                                   style: Theme.of(context)
121:                                       .textTheme
122:                                       .bodySmall
123:                                       ?.copyWith(
124:                                         fontWeight: FontWeight.bold,
125:                                       ),
126:                                 )
127:                               : null,
128:                           onTap: () {
129:                             _removeOverlay();
130:                             _searchController.clear();
131:                             setState(() => _isSearching = false);
132:                             Navigator.of(context).push(
133:                               MaterialPageRoute(
134:                                 builder: (context) =>
135:                                     CardDetailScreen(card: card),
136:                               ),
137:                             );
138:                           },
139:                         );
140:                       },
141:                     );
142:                   },
143:                   loading: () => const Center(
144:                     child: Padding(
145:                       padding: EdgeInsets.all(16.0),
146:                       child: CircularProgressIndicator(),
147:                     ),
148:                   ),
149:                   error: (error, stackTrace) {
150:                     _logger.severe('Search error', error, stackTrace);
151:                     return const Padding(
152:                       padding: EdgeInsets.all(16.0),
153:                       child: Text('Error searching cards'),
154:                     );
155:                   },
156:                 );
157:               },
158:             ),
159:           ),
160:         ),
161:       ),
162:     );
163: 
164:     Overlay.of(context).insert(_overlayEntry!);
165:   }
166: 
167:   @override
168:   Widget build(BuildContext context) {
169:     return Padding(
170:       padding: const EdgeInsets.all(8.0),
171:       child: Column(
172:         children: [
173:           SearchBar(
174:             controller: _searchController,
175:             hintText: 'Search cards...',
176:             leading: const Icon(Icons.search),
177:             trailing: [
178:               if (_isSearching)
179:                 IconButton(
180:                   icon: const Icon(Icons.clear),
181:                   onPressed: () {
182:                     _searchController.clear();
183:                     _onSearchChanged('');
184:                     _removeOverlay();
185:                   },
186:                 ),
187:             ],
188:             onChanged: _onSearchChanged,
189:             padding: const WidgetStatePropertyAll<EdgeInsets>(
190:               EdgeInsets.symmetric(horizontal: 16.0),
191:             ),
192:           ),
193:         ],
194:       ),
195:     );
196:   }
197: }
198: 
199: class Debouncer {
200:   final int milliseconds;
201:   Timer? _timer;
202: 
203:   Debouncer({required this.milliseconds});
204: 
205:   void run(VoidCallback action) {
206:     _timer?.cancel();
207:     _timer = Timer(Duration(milliseconds: milliseconds), action);
208:   }
209: 
210:   void dispose() {
211:     _timer?.cancel();
212:     _timer = null;
213:   }
214: }
</file>

<file path="lib/features/cards/presentation/widgets/sort_menu_button.dart">
  1: import 'package:flutter/material.dart';
  2: import 'package:flutter_riverpod/flutter_riverpod.dart';
  3: import '../../models/card_filter_options.dart';
  4: import '../../providers/card_providers.dart';
  5: import '../../../../core/logging/logger_service.dart';
  6: 
  7: class SortMenuButton extends ConsumerWidget {
  8:   const SortMenuButton({super.key});
  9: 
 10:   @override
 11:   Widget build(BuildContext context, WidgetRef ref) {
 12:     final cardState = ref.watch(cardNotifierProvider);
 13:     final currentSort =
 14:         cardState.filterOptions?.sortOption ?? CardSortOption.setNumber;
 15:     final isAscending = cardState.filterOptions?.ascending ?? true;
 16:     final logger = LoggerService();
 17: 
 18:     return PopupMenuButton<(CardSortOption, bool)>(
 19:       initialValue: (currentSort, isAscending),
 20:       tooltip: 'Sort cards',
 21:       icon: const Icon(Icons.sort),
 22:       onSelected: (value) {
 23:         logger.info(
 24:             'Changing sort option to: ${value.$1}, ascending: ${value.$2}');
 25:         final currentFilters =
 26:             cardState.filterOptions ?? const CardFilterOptions();
 27:         ref.read(cardNotifierProvider.notifier).updateFilters(
 28:               currentFilters.copyWith(
 29:                 sortOption: value.$1,
 30:                 ascending: value.$2,
 31:               ),
 32:             );
 33:       },
 34:       itemBuilder: (BuildContext context) => [
 35:         ..._buildSortMenuItem(
 36:           'Set Number',
 37:           CardSortOption.setNumber,
 38:           currentSort,
 39:           isAscending,
 40:           showAscDesc: false,
 41:         ),
 42:         const PopupMenuDivider(),
 43:         ..._buildSortMenuItem(
 44:           'Name',
 45:           CardSortOption.nameAsc,
 46:           currentSort,
 47:           isAscending,
 48:         ),
 49:         const PopupMenuDivider(),
 50:         ..._buildSortMenuItem(
 51:           'Cost',
 52:           CardSortOption.costAsc,
 53:           currentSort,
 54:           isAscending,
 55:         ),
 56:         const PopupMenuDivider(),
 57:         ..._buildSortMenuItem(
 58:           'Power',
 59:           CardSortOption.powerAsc,
 60:           currentSort,
 61:           isAscending,
 62:         ),
 63:         const PopupMenuDivider(),
 64:         ..._buildSortMenuItem(
 65:           'Release Date',
 66:           CardSortOption.releaseDate,
 67:           currentSort,
 68:           isAscending,
 69:           showAscDesc: false,
 70:         ),
 71:       ],
 72:     );
 73:   }
 74: 
 75:   List<PopupMenuEntry<(CardSortOption, bool)>> _buildSortMenuItem(
 76:     String title,
 77:     CardSortOption option,
 78:     CardSortOption currentOption,
 79:     bool currentAscending, {
 80:     bool showAscDesc = true,
 81:   }) {
 82:     if (!showAscDesc) {
 83:       return [
 84:         PopupMenuItem(
 85:           value: (option, true),
 86:           child: Row(
 87:             children: [
 88:               Text(title),
 89:               const SizedBox(width: 8),
 90:               if (currentOption == option && currentAscending)
 91:                 const Icon(Icons.check, size: 20),
 92:             ],
 93:           ),
 94:         ),
 95:       ];
 96:     }
 97: 
 98:     return [
 99:       PopupMenuItem(
100:         value: (option, true),
101:         child: Row(
102:           mainAxisAlignment: MainAxisAlignment.spaceBetween,
103:           children: [
104:             Text('$title (A-Z)'),
105:             if (currentOption == option && currentAscending)
106:               const Icon(Icons.check, size: 20),
107:           ],
108:         ),
109:       ),
110:       PopupMenuItem(
111:         value: (option, false),
112:         child: Row(
113:           mainAxisAlignment: MainAxisAlignment.spaceBetween,
114:           children: [
115:             Text('$title (Z-A)'),
116:             if (currentOption == option && !currentAscending)
117:               const Icon(Icons.check, size: 20),
118:           ],
119:         ),
120:       ),
121:     ];
122:   }
123: }
</file>

<file path="lib/features/cards/providers/card_notifier.dart">
  1: import 'dart:async';
  2: import 'package:flutter_riverpod/flutter_riverpod.dart';
  3: import '../../../core/logging/logger_service.dart';
  4: import '../repositories/card_repository.dart';
  5: import '../services/card_cache_service.dart';
  6: import '../models/card_filter_options.dart';
  7: import '../models/fftcg_card.dart';
  8: import 'card_state.dart';
  9: 
 10: class CardNotifier extends StateNotifier<CardState> {
 11:   final CardRepository _repository;
 12:   final CardCacheService _cacheService;
 13:   final LoggerService _logger;
 14:   StreamSubscription? _cardsSubscription;
 15: 
 16:   CardNotifier({
 17:     required CardRepository repository,
 18:     required CardCacheService cacheService,
 19:     LoggerService? logger,
 20:   })  : _repository = repository,
 21:         _cacheService = cacheService,
 22:         _logger = logger ?? LoggerService(),
 23:         super(const CardState()) {
 24:     _initializeCards();
 25:   }
 26: 
 27:   void _initializeCards() {
 28:     _logger.info('Initializing cards stream');
 29:     final savedFilters = _cacheService.getFilterOptions();
 30:     if (savedFilters != null) {
 31:       state = state.copyWith(filterOptions: savedFilters);
 32:       _logger.info('Restored saved filters: ${savedFilters.toJson()}');
 33:     }
 34:     _watchCards();
 35:   }
 36: 
 37:   void _watchCards() {
 38:     state = state.copyWith(status: CardLoadingStatus.loading);
 39: 
 40:     _cardsSubscription?.cancel();
 41: 
 42:     try {
 43:       _cardsSubscription = _repository
 44:           .watchCards(
 45:             searchQuery: state.searchQuery,
 46:             elements: state.filterOptions?.elements,
 47:             cardType: state.filterOptions?.cardType,
 48:             cost: state.filterOptions?.costs?.join(','),
 49:           )
 50:           .map((cards) => _applyFiltersAndSort(cards))
 51:           .listen(
 52:         (cards) {
 53:           state = state.copyWith(
 54:             status: CardLoadingStatus.loaded,
 55:             cards: cards,
 56:             errorMessage: null,
 57:           );
 58:           _logger.info('Cards loaded and sorted: ${cards.length}');
 59:         },
 60:         onError: (error, stackTrace) {
 61:           state = state.copyWith(
 62:             status: CardLoadingStatus.error,
 63:             errorMessage: 'Failed to load cards',
 64:           );
 65:           _logger.severe('Error loading cards', error, stackTrace);
 66:         },
 67:       );
 68:     } catch (e, stackTrace) {
 69:       _logger.severe('Error setting up cards stream', e, stackTrace);
 70:       state = state.copyWith(
 71:         status: CardLoadingStatus.error,
 72:         errorMessage: 'Failed to initialize card loading',
 73:       );
 74:     }
 75:   }
 76: 
 77:   List<FFTCGCard> _applyFiltersAndSort(List<FFTCGCard> cards) {
 78:     var filteredCards = List<FFTCGCard>.from(cards);
 79:     final filters = state.filterOptions;
 80: 
 81:     if (filters != null) {
 82:       // Apply additional filters
 83:       if (filters.rarities?.isNotEmpty ?? false) {
 84:         filteredCards = filteredCards
 85:             .where((card) => filters.rarities!.contains(card.rarity))
 86:             .toList();
 87:       }
 88: 
 89:       if (filters.job != null) {
 90:         filteredCards = filteredCards
 91:             .where(
 92:                 (card) => card.job?.toLowerCase() == filters.job?.toLowerCase())
 93:             .toList();
 94:       }
 95: 
 96:       if (filters.category != null) {
 97:         filteredCards = filteredCards
 98:             .where((card) =>
 99:                 card.category?.toLowerCase() == filters.category?.toLowerCase())
100:             .toList();
101:       }
102: 
103:       if (filters.opus?.isNotEmpty ?? false) {
104:         filteredCards = filteredCards.where((card) {
105:           final cardOpus = card.cardNumber?.split('-').first;
106:           return filters.opus!.contains(cardOpus);
107:         }).toList();
108:       }
109: 
110:       if (filters.powerRange != null) {
111:         final range = filters.powerRange!.split('-');
112:         if (range.length == 2) {
113:           final minPower = int.tryParse(range[0]) ?? 0;
114:           final maxPower = int.tryParse(range[1]) ?? 0;
115:           filteredCards = filteredCards.where((card) {
116:             final power = int.tryParse(card.power ?? '') ?? 0;
117:             return power >= minPower && power <= maxPower;
118:           }).toList();
119:         }
120:       }
121: 
122:       // Apply sorting
123:       switch (filters.sortOption) {
124:         case CardSortOption.nameAsc:
125:         case CardSortOption.nameDesc:
126:           filteredCards.sort((a, b) => filters.ascending
127:               ? a.name.compareTo(b.name)
128:               : b.name.compareTo(a.name));
129:           break;
130: 
131:         case CardSortOption.costAsc:
132:         case CardSortOption.costDesc:
133:           filteredCards.sort((a, b) {
134:             final aCost = int.tryParse(a.cost ?? '') ?? 0;
135:             final bCost = int.tryParse(b.cost ?? '') ?? 0;
136:             return filters.ascending
137:                 ? aCost.compareTo(bCost)
138:                 : bCost.compareTo(aCost);
139:           });
140:           break;
141: 
142:         case CardSortOption.powerAsc:
143:         case CardSortOption.powerDesc:
144:           filteredCards.sort((a, b) {
145:             final aPower = int.tryParse(a.power ?? '') ?? 0;
146:             final bPower = int.tryParse(b.power ?? '') ?? 0;
147:             return filters.ascending
148:                 ? aPower.compareTo(bPower)
149:                 : bPower.compareTo(aPower);
150:           });
151:           break;
152: 
153:         case CardSortOption.setNumber:
154:           filteredCards.sort((a, b) {
155:             final aNumber = a.cardNumber ?? '';
156:             final bNumber = b.cardNumber ?? '';
157:             return filters.ascending
158:                 ? aNumber.compareTo(bNumber)
159:                 : bNumber.compareTo(aNumber);
160:           });
161:           break;
162: 
163:         case CardSortOption.releaseDate:
164:           filteredCards.sort((a, b) {
165:             final aDate = a.modifiedOn ?? '';
166:             final bDate = b.modifiedOn ?? '';
167:             return filters.ascending
168:                 ? aDate.compareTo(bDate)
169:                 : bDate.compareTo(aDate);
170:           });
171:           break;
172:       }
173:     }
174: 
175:     return filteredCards;
176:   }
177: 
178:   void toggleViewMode() {
179:     state = state.copyWith(isGridView: !state.isGridView);
180:     _logger.info('View mode changed to: ${state.isGridView ? 'grid' : 'list'}');
181:   }
182: 
183:   void updateFilters(CardFilterOptions options) {
184:     _logger.info('Updating filters: ${options.toJson()}');
185:     state = state.copyWith(
186:       status: CardLoadingStatus.loading,
187:       filterOptions: options,
188:     );
189:     _cacheService.saveFilterOptions(options);
190:     _watchCards();
191:   }
192: 
193:   void updateSearch(String? query) {
194:     if (query == state.searchQuery) return;
195: 
196:     _logger.info('Updating search query: $query');
197:     state = state.copyWith(
198:       searchQuery: query,
199:       status: CardLoadingStatus.loading,
200:     );
201:     _watchCards();
202:   }
203: 
204:   Future<void> refreshCards() async {
205:     _logger.info('Manually refreshing cards');
206:     _watchCards();
207:   }
208: 
209:   @override
210:   void dispose() {
211:     _logger.info('Disposing CardNotifier');
212:     _cardsSubscription?.cancel();
213:     super.dispose();
214:   }
215: }
</file>

<file path="lib/features/cards/providers/card_providers.dart">
  1: import 'package:flutter_riverpod/flutter_riverpod.dart';
  2: import 'package:shared_preferences/shared_preferences.dart';
  3: import '../repositories/card_repository.dart';
  4: import '../services/card_cache_service.dart';
  5: import 'card_notifier.dart';
  6: import 'card_state.dart';
  7: import '../models/fftcg_card.dart';
  8: import '../models/card_filter_options.dart';
  9: 
 10: // Core providers
 11: final sharedPreferencesProvider = Provider<SharedPreferences>((ref) {
 12:   throw UnimplementedError('Must be overridden in main.dart');
 13: });
 14: 
 15: // Service providers
 16: final cardCacheServiceProvider = Provider<CardCacheService>((ref) {
 17:   return CardCacheService(
 18:     prefs: ref.watch(sharedPreferencesProvider),
 19:   );
 20: });
 21: 
 22: final cardRepositoryProvider = Provider<CardRepository>((ref) {
 23:   return CardRepository();
 24: });
 25: 
 26: // Main card state provider
 27: final cardNotifierProvider =
 28:     StateNotifierProvider<CardNotifier, CardState>((ref) {
 29:   return CardNotifier(
 30:     repository: ref.watch(cardRepositoryProvider),
 31:     cacheService: ref.watch(cardCacheServiceProvider),
 32:   );
 33: });
 34: 
 35: // Convenience providers for card data
 36: final cardsProvider = Provider<List<FFTCGCard>>((ref) {
 37:   return ref.watch(cardNotifierProvider).cards;
 38: });
 39: 
 40: final filteredCardsProvider = Provider<List<FFTCGCard>>((ref) {
 41:   final state = ref.watch(cardNotifierProvider);
 42:   final filters = state.filterOptions;
 43:   if (filters == null) return state.cards;
 44: 
 45:   return state.cards.where((card) {
 46:     if (filters.elements?.isNotEmpty ?? false) {
 47:       if (!card.elements
 48:           .any((element) => filters.elements!.contains(element))) {
 49:         return false;
 50:       }
 51:     }
 52:     if (filters.cardType != null && card.cardType != filters.cardType) {
 53:       return false;
 54:     }
 55:     if (filters.costs?.isNotEmpty ?? false) {
 56:       if (!filters.costs!.contains(card.cost)) {
 57:         return false;
 58:       }
 59:     }
 60:     return true;
 61:   }).toList();
 62: });
 63: 
 64: // Status providers
 65: final cardLoadingStatusProvider = Provider<CardLoadingStatus>((ref) {
 66:   return ref.watch(cardNotifierProvider).status;
 67: });
 68: 
 69: final isGridViewProvider = Provider<bool>((ref) {
 70:   return ref.watch(cardNotifierProvider).isGridView;
 71: });
 72: 
 73: // Filter-related providers
 74: final uniqueElementsProvider = FutureProvider<List<String>>((ref) async {
 75:   return ref.read(cardRepositoryProvider).getUniqueElements();
 76: });
 77: 
 78: final uniqueCardTypesProvider = FutureProvider<List<String>>((ref) async {
 79:   return ref.read(cardRepositoryProvider).getUniqueCardTypes();
 80: });
 81: 
 82: final uniqueRaritiesProvider = FutureProvider<List<String>>((ref) async {
 83:   final cards = await ref.read(cardRepositoryProvider).getAllCards();
 84:   return cards
 85:       .map((card) => card.rarity)
 86:       .where((rarity) => rarity != null)
 87:       .toSet()
 88:       .cast<String>()
 89:       .toList();
 90: });
 91: 
 92: final uniqueOpusProvider = FutureProvider<List<String>>((ref) async {
 93:   final cards = await ref.read(cardRepositoryProvider).getAllCards();
 94:   return cards
 95:       .map((card) => card.cardNumber?.split('-').first)
 96:       .where((opus) => opus != null)
 97:       .toSet()
 98:       .cast<String>()
 99:       .toList();
100: });
101: 
102: // Search providers
103: final searchResultsProvider = FutureProvider.family<List<FFTCGCard>, String>(
104:   (ref, query) async {
105:     if (query.isEmpty) return [];
106:     return ref.read(cardRepositoryProvider).searchCards(query);
107:   },
108: );
109: 
110: // Card detail providers
111: final cardByNumberProvider = FutureProvider.family<FFTCGCard?, String>(
112:   (ref, cardNumber) async {
113:     return ref.read(cardRepositoryProvider).getCardByNumber(cardNumber);
114:   },
115: );
116: 
117: // Recent cards provider
118: final recentCardsProvider = Provider<List<String>>((ref) {
119:   return ref.read(cardCacheServiceProvider).getRecentCards();
120: });
121: 
122: // Filter state providers
123: final selectedFiltersProvider = Provider<CardFilterOptions?>((ref) {
124:   return ref.watch(cardNotifierProvider).filterOptions;
125: });
126: 
127: final selectedElementsProvider = Provider<List<String>?>((ref) {
128:   return ref.watch(selectedFiltersProvider)?.elements;
129: });
130: 
131: final selectedCardTypeProvider = Provider<String?>((ref) {
132:   return ref.watch(selectedFiltersProvider)?.cardType;
133: });
134: 
135: final selectedCostsProvider = Provider<List<String>?>((ref) {
136:   return ref.watch(selectedFiltersProvider)?.costs;
137: });
138: 
139: final selectedRaritiesProvider = Provider<List<String>?>((ref) {
140:   return ref.watch(selectedFiltersProvider)?.rarities;
141: });
142: 
143: final selectedOpusProvider = Provider<List<String>?>((ref) {
144:   return ref.watch(selectedFiltersProvider)?.opus;
145: });
146: 
147: // Error handling provider
148: final cardErrorMessageProvider = Provider<String?>((ref) {
149:   return ref.watch(cardNotifierProvider).errorMessage;
150: });
151: 
152: // Sort-related providers
153: final currentSortOptionProvider = Provider<CardSortOption>((ref) {
154:   return ref.watch(selectedFiltersProvider)?.sortOption ??
155:       CardSortOption.setNumber;
156: });
157: 
158: final sortAscendingProvider = Provider<bool>((ref) {
159:   return ref.watch(selectedFiltersProvider)?.ascending ?? true;
160: });
</file>

<file path="lib/features/cards/providers/card_state.dart">
 1: import '../models/card_filter_options.dart';
 2: import '../models/fftcg_card.dart';
 3: 
 4: enum CardLoadingStatus {
 5:   initial,
 6:   loading,
 7:   loaded,
 8:   error,
 9: }
10: 
11: class CardState {
12:   final CardLoadingStatus status;
13:   final List<FFTCGCard> cards;
14:   final String? errorMessage;
15:   final bool isGridView;
16:   final String? searchQuery;
17:   final CardFilterOptions? filterOptions;
18: 
19:   const CardState({
20:     this.status = CardLoadingStatus.initial,
21:     this.cards = const [],
22:     this.errorMessage,
23:     this.isGridView = true,
24:     this.searchQuery,
25:     this.filterOptions,
26:   });
27: 
28:   CardState copyWith({
29:     CardLoadingStatus? status,
30:     List<FFTCGCard>? cards,
31:     String? errorMessage,
32:     bool? isGridView,
33:     String? searchQuery,
34:     CardFilterOptions? filterOptions,
35:   }) {
36:     return CardState(
37:       status: status ?? this.status,
38:       cards: cards ?? this.cards,
39:       errorMessage: errorMessage ?? this.errorMessage,
40:       isGridView: isGridView ?? this.isGridView,
41:       searchQuery: searchQuery ?? this.searchQuery,
42:       filterOptions: filterOptions ?? this.filterOptions,
43:     );
44:   }
45: }
</file>

<file path="lib/features/cards/repositories/card_repository.dart">
  1: // lib/features/cards/repositories/card_repository.dart
  2: 
  3: import 'package:cloud_firestore/cloud_firestore.dart';
  4: import '../../../core/logging/logger_service.dart';
  5: import '../../../core/services/hive_service.dart';
  6: import '../../../core/services/connectivity_service.dart';
  7: import '../models/fftcg_card.dart';
  8: import '../../../core/models/sync_status.dart';
  9: import '../../auth/services/auth_service.dart';
 10: import 'package:shared_preferences/shared_preferences.dart';
 11: 
 12: class CardRepository {
 13:   final FirebaseFirestore _firestore;
 14:   final HiveService _hiveService;
 15:   final LoggerService _logger;
 16:   final AuthService _authService;
 17:   final ConnectivityService _connectivityService;
 18: 
 19:   static const String _collectionName = 'cards';
 20:   static const int _batchSize = 500;
 21:   static const Duration _cacheExpiration = Duration(hours: 24);
 22:   static const String _lastCacheTimeKey = 'last_cache_time';
 23: 
 24:   CardRepository({
 25:     FirebaseFirestore? firestore,
 26:     HiveService? hiveService,
 27:     LoggerService? logger,
 28:     AuthService? authService,
 29:     ConnectivityService? connectivityService,
 30:   })  : _firestore = firestore ?? FirebaseFirestore.instance,
 31:         _hiveService = hiveService ?? HiveService(),
 32:         _logger = logger ?? LoggerService(),
 33:         _authService = authService ?? AuthService(),
 34:         _connectivityService = connectivityService ?? ConnectivityService();
 35: 
 36:   Stream<List<FFTCGCard>> watchCards({
 37:     String? searchQuery,
 38:     List<String>? elements,
 39:     String? cardType,
 40:     String? cost,
 41:   }) async* {
 42:     try {
 43:       // Get local cards outside the main try block so it's available in catch
 44:       List<FFTCGCard> localResults = _getLocalCards(
 45:         searchQuery: searchQuery,
 46:         elements: elements,
 47:         cardType: cardType,
 48:         cost: cost,
 49:       );
 50: 
 51:       // First, yield local data
 52:       yield localResults;
 53: 
 54:       // Check if we're in guest mode
 55:       final isGuest = await _authService.isGuestSession();
 56:       if (isGuest) {
 57:         _logger.info('In guest mode - using local data only');
 58:         return;
 59:       }
 60: 
 61:       // Check connectivity
 62:       final isConnected = await _connectivityService.hasStableConnection();
 63:       if (!isConnected) {
 64:         _logger.info('No stable connection - using local data only');
 65:         return;
 66:       }
 67: 
 68:       // Build the query
 69:       Query query = _firestore.collection(_collectionName);
 70: 
 71:       if (searchQuery != null && searchQuery.isNotEmpty) {
 72:         query = query
 73:             .where('cleanName',
 74:                 isGreaterThanOrEqualTo: searchQuery.toLowerCase())
 75:             .where('cleanName', isLessThan: '${searchQuery.toLowerCase()}z');
 76:       }
 77: 
 78:       if (cardType != null) {
 79:         query = query.where('extendedData', arrayContains: {
 80:           'name': 'CardType',
 81:           'value': cardType,
 82:         });
 83:       }
 84: 
 85:       // Listen to Firestore updates
 86:       await for (final snapshot in query.snapshots()) {
 87:         try {
 88:           final cards = snapshot.docs.map((doc) {
 89:             final card = FFTCGCard.fromFirestore(doc);
 90:             // Preserve sync status of existing local cards
 91:             final existingCard = _hiveService.getCard(card.cardNumber ?? '');
 92:             if (existingCard != null) {
 93:               return card.copyWith(
 94:                 syncStatus: existingCard.syncStatus,
 95:                 lastModifiedLocally: existingCard.lastModifiedLocally,
 96:               );
 97:             }
 98:             return card;
 99:           }).toList();
100: 
101:           // Apply element filters if specified
102:           final filteredCards = elements?.isNotEmpty == true
103:               ? cards.where((card) =>
104:                   elements!.any((element) => card.elements.contains(element)))
105:               : cards;
106: 
107:           final resultsList = filteredCards.toList();
108: 
109:           // Save to local storage
110:           await _saveCardsLocally(resultsList);
111: 
112:           yield resultsList;
113:         } catch (e, stackTrace) {
114:           _logger.severe('Error processing card snapshot', e, stackTrace);
115:           // Return existing local data on error
116:           yield localResults;
117:         }
118:       }
119:     } catch (e, stackTrace) {
120:       _logger.severe('Error watching cards', e, stackTrace);
121:       // Use _getLocalCards directly in catch block
122:       yield _getLocalCards(
123:         searchQuery: searchQuery,
124:         elements: elements,
125:         cardType: cardType,
126:         cost: cost,
127:       );
128:     }
129:   }
130: 
131:   Future<FFTCGCard?> getCardByNumber(String cardNumber) async {
132:     try {
133:       // First check local storage
134:       final localCard = _hiveService.getCard(cardNumber);
135:       if (localCard != null) {
136:         return localCard;
137:       }
138: 
139:       // Check if we're in guest mode or offline
140:       final isGuest = await _authService.isGuestSession();
141:       final isConnected = await _connectivityService.hasStableConnection();
142:       if (isGuest || !isConnected) {
143:         _logger.info('Using local data only for card lookup');
144:         return null;
145:       }
146: 
147:       // Query Firestore
148:       final querySnapshot = await _retryOperation(() => _firestore
149:           .collection(_collectionName)
150:           .where('extendedData', arrayContains: {
151:             'name': 'Number',
152:             'value': cardNumber,
153:           })
154:           .limit(1)
155:           .get());
156: 
157:       if (querySnapshot.docs.isEmpty) {
158:         _logger.warning('Card not found: $cardNumber');
159:         return null;
160:       }
161: 
162:       final card = FFTCGCard.fromFirestore(querySnapshot.docs.first);
163:       await _hiveService.saveCard(card);
164:       return card;
165:     } catch (e, stackTrace) {
166:       _logger.severe('Error getting card by number', e, stackTrace);
167:       rethrow;
168:     }
169:   }
170: 
171:   Future<List<FFTCGCard>> searchCards(String query) async {
172:     try {
173:       // First search locally
174:       final localCards = _getLocalCards(searchQuery: query);
175:       if (localCards.isNotEmpty) {
176:         return localCards;
177:       }
178: 
179:       // Check if we should query Firestore
180:       final isGuest = await _authService.isGuestSession();
181:       final isConnected = await _connectivityService.hasStableConnection();
182:       if (isGuest || !isConnected) {
183:         _logger.info('Using local data only for search');
184:         return localCards;
185:       }
186: 
187:       // Query Firestore with retry logic
188:       final querySnapshot = await _retryOperation(() => _firestore
189:           .collection(_collectionName)
190:           .where('cleanName', isGreaterThanOrEqualTo: query.toLowerCase())
191:           .where('cleanName', isLessThan: '${query.toLowerCase()}z')
192:           .limit(20)
193:           .get());
194: 
195:       final cards = querySnapshot.docs
196:           .map((doc) => FFTCGCard.fromFirestore(doc))
197:           .toList();
198: 
199:       // Cache search results
200:       await _saveCardsLocally(cards);
201: 
202:       return cards;
203:     } catch (e, stackTrace) {
204:       _logger.severe('Error searching cards', e, stackTrace);
205:       // Return local results on error
206:       return _getLocalCards(searchQuery: query);
207:     }
208:   }
209: 
210:   Future<List<String>> getUniqueElements() async {
211:     try {
212:       // First check local storage
213:       final localCards = _hiveService.getAllCards();
214:       if (localCards.isNotEmpty) {
215:         return localCards
216:             .expand((card) => card.elements)
217:             .toSet()
218:             .toList()
219:           ..sort();
220:       }
221: 
222:       // Check if we should query Firestore
223:       final isGuest = await _authService.isGuestSession();
224:       final isConnected = await _connectivityService.hasStableConnection();
225:       if (isGuest || !isConnected) {
226:         _logger.info('Using local data only for element lookup');
227:         return [];
228:       }
229: 
230:       final querySnapshot = await _retryOperation(
231:         () => _firestore.collection(_collectionName).get(),
232:       );
233: 
234:       final elements = querySnapshot.docs
235:           .map((doc) => FFTCGCard.fromFirestore(doc))
236:           .expand((card) => card.elements)
237:           .toSet()
238:           .toList()
239:         ..sort();
240: 
241:       _logger.info('Found ${elements.length} unique elements');
242:       return elements;
243:     } catch (e, stackTrace) {
244:       _logger.severe('Error getting unique elements', e, stackTrace);
245:       rethrow;
246:     }
247:   }
248: 
249:   Future<List<String>> getUniqueCardTypes() async {
250:     try {
251:       // First check local storage
252:       final localCards = _hiveService.getAllCards();
253:       if (localCards.isNotEmpty) {
254:         return localCards
255:             .map((card) => card.cardType)
256:             .where((type) => type != null)
257:             .toSet()
258:             .cast<String>()
259:             .toList()
260:           ..sort();
261:       }
262: 
263:       // Check if we should query Firestore
264:       final isGuest = await _authService.isGuestSession();
265:       final isConnected = await _connectivityService.hasStableConnection();
266:       if (isGuest || !isConnected) {
267:         _logger.info('Using local data only for card type lookup');
268:         return [];
269:       }
270: 
271:       final querySnapshot = await _retryOperation(
272:         () => _firestore.collection(_collectionName).get(),
273:       );
274: 
275:       final cardTypes = querySnapshot.docs
276:           .map((doc) => FFTCGCard.fromFirestore(doc))
277:           .map((card) => card.cardType)
278:           .where((type) => type != null)
279:           .toSet()
280:           .cast<String>()
281:           .toList()
282:         ..sort();
283: 
284:       _logger.info('Found ${cardTypes.length} unique card types');
285:       return cardTypes;
286:     } catch (e, stackTrace) {
287:       _logger.severe('Error getting unique card types', e, stackTrace);
288:       rethrow;
289:     }
290:   }
291: 
292:   Future<List<FFTCGCard>> getAllCards() async {
293:     try {
294:       // First check local storage
295:       final localCards = _hiveService.getAllCards();
296:       if (localCards.isNotEmpty) {
297:         return localCards;
298:       }
299: 
300:       // Check if we should query Firestore
301:       final isGuest = await _authService.isGuestSession();
302:       final isConnected = await _connectivityService.hasStableConnection();
303:       if (isGuest || !isConnected) {
304:         _logger.info('Using local data only for full card list');
305:         return localCards;
306:       }
307: 
308:       // Fetch in batches to handle large datasets
309:       final List<FFTCGCard> allCards = [];
310:       DocumentSnapshot? lastDocument;
311:       bool hasMoreData = true;
312: 
313:       while (hasMoreData) {
314:         Query query = _firestore
315:             .collection(_collectionName)
316:             .orderBy(FieldPath.documentId)
317:             .limit(_batchSize);
318: 
319:         if (lastDocument != null) {
320:           query = query.startAfterDocument(lastDocument);
321:         }
322: 
323:         final querySnapshot = await _retryOperation(() => query.get());
324:         
325:         if (querySnapshot.docs.isEmpty) {
326:           hasMoreData = false;
327:           continue;
328:         }
329: 
330:         final batchCards = querySnapshot.docs
331:             .map((doc) => FFTCGCard.fromFirestore(doc))
332:             .toList();
333: 
334:         allCards.addAll(batchCards);
335:         lastDocument = querySnapshot.docs.last;
336: 
337:         // Save batch to local storage
338:         await _saveCardsLocally(batchCards);
339:         
340:         _logger.info('Fetched batch of ${batchCards.length} cards');
341:       }
342: 
343:       _logger.info('Retrieved total of ${allCards.length} cards');
344:       return allCards;
345:     } catch (e, stackTrace) {
346:       _logger.severe('Error getting all cards', e, stackTrace);
347:       rethrow;
348:     }
349:   }
350: 
351:   List<FFTCGCard> _getLocalCards({
352:     String? searchQuery,
353:     List<String>? elements,
354:     String? cardType,
355:     String? cost,
356:   }) {
357:     try {
358:       var cards = _hiveService.getAllCards();
359: 
360:       // Apply filters
361:       if (searchQuery?.isNotEmpty == true) {
362:         cards = cards
363:             .where((card) =>
364:                 card.name.toLowerCase().contains(searchQuery!.toLowerCase()) ||
365:                 (card.cardNumber?.toLowerCase().contains(searchQuery.toLowerCase()) ??
366:                     false))
367:             .toList();
368:       }
369: 
370:       if (elements?.isNotEmpty == true) {
371:         cards = cards
372:             .where((card) =>
373:                 elements!.any((element) => card.elements.contains(element)))
374:             .toList();
375:       }
376: 
377:       if (cardType != null) {
378:         cards = cards.where((card) => card.cardType == cardType).toList();
379:       }
380: 
381:       if (cost != null) {
382:         cards = cards.where((card) => card.cost == cost).toList();
383:       }
384: 
385:       return cards;
386:     } catch (e, stackTrace) {
387:       _logger.severe('Error getting local cards', e, stackTrace);
388:       return [];
389:     }
390:   }
391: 
392:   Future<void> _saveCardsLocally(List<FFTCGCard> cards) async {
393:     try {
394:       await _hiveService.saveCards(cards);
395:       _logger.info('Saved ${cards.length} cards locally');
396:     } catch (e, stackTrace) {
397:       _logger.severe('Error saving cards locally', e, stackTrace);
398:       rethrow;
399:     }
400:   }
401: 
402:   Future<void> saveCardLocally(FFTCGCard card) async {
403:     try {
404:       await _hiveService.saveCard(card);
405:       _logger.info('Card saved locally: ${card.cardNumber}');
406:     } catch (e, stackTrace) {
407:       _logger.severe('Error saving card locally', e, stackTrace);
408:       rethrow;
409:     }
410:   }
411: 
412:   Future<void> deleteCardLocally(String cardNumber) async {
413:     try {
414:       await _hiveService.deleteCard(cardNumber);
415:       _logger.info('Card deleted locally: $cardNumber');
416:     } catch (e, stackTrace) {
417:       _logger.severe('Error deleting card locally', e, stackTrace);
418:       rethrow;
419:     }
420:   }
421: 
422:   Future<void> markCardForSync(String cardNumber) async {
423:     try {
424:       final card = _hiveService.getCard(cardNumber);
425:       if (card != null) {
426:         card.markForSync();
427:         await _hiveService.saveCard(card);
428:         _logger.info('Card marked for sync: $cardNumber');
429:       }
430:     } catch (e, stackTrace) {
431:       _logger.severe('Error marking card for sync', e, stackTrace);
432:       rethrow;
433:     }
434:   }
435: 
436:   Future<void> syncUserData(String userId) async {
437:     try {
438:       _logger.info('Starting user data sync for ID: $userId');
439: 
440:       // Check if we're in guest mode
441:       final isGuest = await _authService.isGuestSession();
442:       if (isGuest) {
443:         _logger.info('Skipping sync for guest user');
444:         return;
445:       }
446: 
447:       // Check connectivity
448:       final isConnected = await _connectivityService.hasStableConnection();
449:       if (!isConnected) {
450:         throw Exception('No stable connection available for sync');
451:       }
452: 
453:       // Get all locally modified cards
454:       final localCards = _hiveService
455:           .getAllCards()
456:           .where((card) => card.syncStatus == SyncStatus.pending)
457:           .toList();
458: 
459:       if (localCards.isEmpty) {
460:         _logger.info('No local changes to sync');
461:         return;
462:       }
463: 
464:       // Process in batches
465:       for (var i = 0; i < localCards.length; i += _batchSize) {
466:         final end = (i + _batchSize < localCards.length)
467:             ? i + _batchSize
468:             : localCards.length;
469:         final batch = _firestore.batch();
470:         final currentBatch = localCards.sublist(i, end);
471: 
472:         for (final card in currentBatch) {
473:           final docRef = _firestore
474:               .collection('users')
475:               .doc(userId)
476:               .collection('cards')
477:               .doc(card.cardNumber);
478: 
479:           batch.set(
480:             docRef,
481:             {
482:               ...card.toMap(),
483:               'lastModified': FieldValue.serverTimestamp(),
484:               'syncStatus': 'synced',
485:             },
486:             SetOptions(merge: true),
487:           );
488:         }
489: 
490:         await _retryOperation(() => batch.commit());
491: 
492:         // Update local sync status
493:         for (final card in currentBatch) {
494:           card.markSynced();
495:           await _hiveService.saveCard(card);
496:         }
497: 
498:         _logger.info(
499:             'Synced batch of ${currentBatch.length} cards ($end/${localCards.length})');
500:       }
501: 
502:       _logger.info('Successfully synced ${localCards.length} cards');
503:     } catch (e, stackTrace) {
504:       _logger.severe('Error syncing user data', e, stackTrace);
505:       rethrow;
506:     }
507:   }
508: 
509:   Future<void> clearLocalData() async {
510:     try {
511:       await _hiveService.clearAll();
512:       _logger.info('Local data cleared successfully');
513:     } catch (e, stackTrace) {
514:       _logger.severe('Error clearing local data', e, stackTrace);
515:       rethrow;
516:     }
517:   }
518: 
519:   Future<T> _retryOperation<T>(Future<T> Function() operation) async {
520:     int attempts = 0;
521:     const maxAttempts = 3;
522:     const retryDelay = Duration(seconds: 2);
523: 
524:     while (attempts < maxAttempts) {
525:       try {
526:         return await operation();
527:       } catch (e) {
528:         attempts++;
529:         if (attempts >= maxAttempts) rethrow;
530: 
531:         // Fixed string interpolation
532:         _logger.warning(
533:             'Operation failed, attempt $attempts of $maxAttempts. Retrying in $retryDelay.inSeconds s');
534:         await Future.delayed(retryDelay);
535:       }
536:     }
537: 
538:     throw CardRepositoryException(
539:       'Operation failed after $maxAttempts attempts',
540:       code: 'retry-exhausted',
541:     );
542:   }
543: 
544:   Future<bool> isCacheValid() async {
545:     try {
546:       final prefs = await SharedPreferences.getInstance();
547:       final lastCacheTime = prefs.getInt(_lastCacheTimeKey);
548: 
549:       if (lastCacheTime == null) return false;
550: 
551:       final lastCacheDateTime =
552:           DateTime.fromMillisecondsSinceEpoch(lastCacheTime);
553:       return DateTime.now().difference(lastCacheDateTime) < _cacheExpiration;
554:     } catch (e, stackTrace) {
555:       _logger.severe('Error checking cache validity', e, stackTrace);
556:       return false;
557:     }
558:   }
559: 
560:   Future<void> updateCacheTimestamp() async {
561:     try {
562:       final prefs = await SharedPreferences.getInstance();
563:       final timestamp = DateTime.now().millisecondsSinceEpoch;
564: 
565:       final success = await prefs.setInt(_lastCacheTimeKey, timestamp);
566:       if (!success) {
567:         throw CardRepositoryException(
568:           'Failed to update cache timestamp',
569:           code: 'cache-update-failed',
570:         );
571:       }
572: 
573:       _logger.info('Cache timestamp updated successfully');
574:     } catch (e, stackTrace) {
575:       _logger.severe('Error updating cache timestamp', e, stackTrace);
576:       throw CardRepositoryException(
577:         'Failed to update cache timestamp',
578:         code: 'cache-update-failed',
579:         originalError: e,
580:       );
581:     }
582:   }
583: }
584: 
585: class CardRepositoryException implements Exception {
586:   final String message;
587:   final String? code;
588:   final dynamic originalError;
589: 
590:   CardRepositoryException(
591:     this.message, {
592:     this.code,
593:     this.originalError,
594:   });
595: 
596:   @override
597:   String toString() =>
598:       'CardRepositoryException: $message${code != null ? ' (Code: $code)' : ''}';
599: }
</file>

<file path="lib/features/cards/services/card_cache_service.dart">
 1: import 'dart:convert';
 2: import 'package:shared_preferences/shared_preferences.dart'; // Fixed import
 3: import '../../../core/logging/logger_service.dart';
 4: import '../models/card_filter_options.dart';
 5: import '../models/fftcg_card.dart';
 6: 
 7: class CardCacheService {
 8:   final SharedPreferences _prefs;
 9:   final LoggerService _logger;
10:   static const String _filterOptionsKey = 'card_filter_options';
11:   static const String _recentCardsKey = 'recent_cards';
12:   static const int _maxRecentCards = 50;
13: 
14:   CardCacheService({
15:     required SharedPreferences prefs,
16:     LoggerService? logger,
17:   })  : _prefs = prefs,
18:         _logger = logger ?? LoggerService();
19: 
20:   Future<void> saveFilterOptions(CardFilterOptions options) async {
21:     try {
22:       await _prefs.setString(_filterOptionsKey, jsonEncode(options.toJson()));
23:       _logger.info('Filter options saved to cache');
24:     } catch (e, stackTrace) {
25:       _logger.severe('Error saving filter options', e, stackTrace);
26:     }
27:   }
28: 
29:   CardFilterOptions? getFilterOptions() {
30:     try {
31:       final String? data = _prefs.getString(_filterOptionsKey);
32:       if (data == null) return null;
33:       return CardFilterOptions.fromJson(jsonDecode(data));
34:     } catch (e, stackTrace) {
35:       _logger.severe('Error loading filter options', e, stackTrace);
36:       return null;
37:     }
38:   }
39: 
40:   Future<void> addRecentCard(FFTCGCard card) async {
41:     try {
42:       final List<String> recentCards =
43:           _prefs.getStringList(_recentCardsKey) ?? [];
44:       final String cardNumber = card.cardNumber ?? '';
45: 
46:       if (cardNumber.isNotEmpty) {
47:         recentCards.remove(cardNumber);
48:         recentCards.insert(0, cardNumber);
49: 
50:         if (recentCards.length > _maxRecentCards) {
51:           recentCards.removeLast();
52:         }
53: 
54:         await _prefs.setStringList(_recentCardsKey, recentCards);
55:         _logger.info('Added card to recent cards: $cardNumber');
56:       }
57:     } catch (e, stackTrace) {
58:       _logger.severe('Error adding recent card', e, stackTrace);
59:     }
60:   }
61: 
62:   List<String> getRecentCards() {
63:     try {
64:       return _prefs.getStringList(_recentCardsKey) ?? [];
65:     } catch (e, stackTrace) {
66:       _logger.severe('Error getting recent cards', e, stackTrace);
67:       return [];
68:     }
69:   }
70: 
71:   Future<void> clearRecentCards() async {
72:     try {
73:       await _prefs.remove(_recentCardsKey);
74:       _logger.info('Recent cards cleared');
75:     } catch (e, stackTrace) {
76:       _logger.severe('Error clearing recent cards', e, stackTrace);
77:     }
78:   }
79: }
</file>

<file path="lib/features/collection/presentation/screens/collection_screen.dart">
 1: import 'package:flutter/material.dart';
 2: import '../../../../core/presentation/widgets/app_drawer.dart';
 3: 
 4: class CollectionScreen extends StatelessWidget {
 5:   const CollectionScreen({super.key});
 6: 
 7:   @override
 8:   Widget build(BuildContext context) {
 9:     return Scaffold(
10:       appBar: AppBar(title: const Text('My Collection')),
11:       drawer: const AppDrawer(currentRoute: '/collection'),
12:       body: const Center(
13:         child: Text('Collection Screen - Coming Soon'),
14:       ),
15:     );
16:   }
17: }
</file>

<file path="lib/features/decks/presentation/screens/decks_screen.dart">
 1: import 'package:flutter/material.dart';
 2: import '../../../../core/presentation/widgets/app_drawer.dart';
 3: 
 4: class DecksScreen extends StatelessWidget {
 5:   const DecksScreen({super.key});
 6: 
 7:   @override
 8:   Widget build(BuildContext context) {
 9:     return Scaffold(
10:       appBar: AppBar(title: const Text('Decks')),
11:       drawer: const AppDrawer(currentRoute: '/decks'),
12:       body: const Center(
13:         child: Text('Decks Screen - Coming Soon'),
14:       ),
15:     );
16:   }
17: }
</file>

<file path="lib/features/profile/models/collection_stats.dart">
 1: import 'package:freezed_annotation/freezed_annotation.dart';
 2: 
 3: part 'collection_stats.freezed.dart';
 4: part 'collection_stats.g.dart';
 5: 
 6: @freezed
 7: class CollectionStats with _$CollectionStats {
 8:   const factory CollectionStats({
 9:     required String cardNumber,
10:     required bool isFoil,
11:     required double value,
12:     DateTime? acquired,
13:   }) = _CollectionStats;
14: 
15:   factory CollectionStats.fromJson(Map<String, dynamic> json) =>
16:       _$CollectionStatsFromJson(json);
17: }
</file>

<file path="lib/features/profile/models/deck_stats.dart">
 1: import 'package:freezed_annotation/freezed_annotation.dart';
 2: 
 3: part 'deck_stats.freezed.dart';
 4: part 'deck_stats.g.dart';
 5: 
 6: @freezed
 7: class DeckStats with _$DeckStats {
 8:   const factory DeckStats({
 9:     required String deckId,
10:     required String name,
11:     required Map<String, int> elementCount,
12:     required DateTime created,
13:     DateTime? lastModified,
14:   }) = _DeckStats;
15: 
16:   factory DeckStats.fromJson(Map<String, dynamic> json) =>
17:       _$DeckStatsFromJson(json);
18: }
</file>

<file path="lib/features/profile/models/user_stats.dart">
 1: import 'package:freezed_annotation/freezed_annotation.dart';
 2: 
 3: part 'user_stats.freezed.dart';
 4: part 'user_stats.g.dart';
 5: 
 6: @freezed
 7: class UserStats with _$UserStats {
 8:   const factory UserStats({
 9:     @Default(0) int totalCards,
10:     @Default(0) int foilCards,
11:     @Default(0) int nonFoilCards,
12:     @Default(0.0) double totalValue,
13:     @Default(0) int totalDecks,
14:     String? mostUsedElement,
15:     @Default({}) Map<String, int> elementUsageStats,
16:     DateTime? lastUpdated,
17:   }) = _UserStats;
18: 
19:   factory UserStats.fromJson(Map<String, dynamic> json) =>
20:       _$UserStatsFromJson(json);
21: }
</file>

<file path="lib/features/profile/presentation/screens/profile_screen.dart">
 1: import 'package:flutter/material.dart';
 2: import 'package:flutter_riverpod/flutter_riverpod.dart';
 3: import '../widgets/profile_header.dart';
 4: import '../widgets/collection_stats.dart';
 5: import '../widgets/deck_stats.dart';
 6: import '../../../auth/providers/auth_providers.dart';
 7: import '../../providers/user_stats_provider.dart';
 8: import '../../../settings/presentation/screens/settings_screen.dart';
 9: 
10: class ProfileScreen extends ConsumerWidget {
11:   const ProfileScreen({super.key});
12: 
13:   @override
14:   Widget build(BuildContext context, WidgetRef ref) {
15:     final user = ref.watch(currentUserProvider);
16:     final stats = ref.watch(userStatsProvider);
17: 
18:     return Scaffold(
19:       appBar: AppBar(
20:         title: const Text('Profile'),
21:         actions: [
22:           IconButton(
23:             icon: const Icon(Icons.settings),
24:             onPressed: () {
25:               Navigator.push(
26:                 context,
27:                 MaterialPageRoute(
28:                   builder: (context) => const SettingsScreen(),
29:                 ),
30:               );
31:             },
32:           ),
33:         ],
34:       ),
35:       body: RefreshIndicator(
36:         onRefresh: () async {
37:           ref.invalidate(userStatsProvider);
38:         },
39:         child: ListView(
40:           children: [
41:             ProfileHeader(
42:               userName: user?.displayName ?? 'Guest User',
43:               email: user?.email,
44:               avatarUrl: user?.photoURL,
45:             ),
46:             const Divider(),
47:             Padding(
48:               padding: const EdgeInsets.all(16.0),
49:               child: Text(
50:                 'Collection Stats',
51:                 style: Theme.of(context).textTheme.titleLarge,
52:               ),
53:             ),
54:             CollectionStats(
55:               totalCards: stats.totalCards,
56:               foilCards: stats.foilCards,
57:               nonFoilCards: stats.nonFoilCards,
58:               collectionValue: stats.totalValue,
59:             ),
60:             const Divider(),
61:             Padding(
62:               padding: const EdgeInsets.all(16.0),
63:               child: Text(
64:                 'Deck Stats',
65:                 style: Theme.of(context).textTheme.titleLarge,
66:               ),
67:             ),
68:             DeckStats(
69:               totalDecks: stats.totalDecks,
70:               favoriteElement: stats.mostUsedElement,
71:               elementUsage: stats.elementUsageStats,
72:             ),
73:           ],
74:         ),
75:       ),
76:     );
77:   }
78: }
</file>

<file path="lib/features/profile/presentation/widgets/collection_stats.dart">
 1: import 'package:flutter/material.dart';
 2: 
 3: class CollectionStats extends StatelessWidget {
 4:   final int totalCards;
 5:   final int foilCards;
 6:   final int nonFoilCards;
 7:   final double collectionValue;
 8: 
 9:   const CollectionStats({
10:     super.key,
11:     required this.totalCards,
12:     required this.foilCards,
13:     required this.nonFoilCards,
14:     required this.collectionValue,
15:   });
16: 
17:   @override
18:   Widget build(BuildContext context) {
19:     return Padding(
20:       padding: const EdgeInsets.symmetric(horizontal: 16.0),
21:       child: Card(
22:         child: Padding(
23:           padding: const EdgeInsets.all(16.0),
24:           child: Column(
25:             children: [
26:               _buildStatRow(
27:                 context,
28:                 'Total Cards',
29:                 totalCards.toString(),
30:               ),
31:               const Divider(),
32:               _buildStatRow(
33:                 context,
34:                 'Foil Cards',
35:                 foilCards.toString(),
36:               ),
37:               const Divider(),
38:               _buildStatRow(
39:                 context,
40:                 'Non-Foil Cards',
41:                 nonFoilCards.toString(),
42:               ),
43:               const Divider(),
44:               _buildStatRow(
45:                 context,
46:                 'Collection Value',
47:                 '\$${collectionValue.toStringAsFixed(2)}',
48:               ),
49:             ],
50:           ),
51:         ),
52:       ),
53:     );
54:   }
55: 
56:   Widget _buildStatRow(BuildContext context, String label, String value) {
57:     return Padding(
58:       padding: const EdgeInsets.symmetric(vertical: 8.0),
59:       child: Row(
60:         mainAxisAlignment: MainAxisAlignment.spaceBetween,
61:         children: [
62:           Text(label),
63:           Text(
64:             value,
65:             style: Theme.of(context).textTheme.titleMedium,
66:           ),
67:         ],
68:       ),
69:     );
70:   }
71: }
</file>

<file path="lib/features/profile/presentation/widgets/deck_stats.dart">
 1: import 'package:flutter/material.dart';
 2: 
 3: class DeckStats extends StatelessWidget {
 4:   final int totalDecks;
 5:   final String? favoriteElement;
 6:   final Map<String, int> elementUsage;
 7: 
 8:   const DeckStats({
 9:     super.key,
10:     required this.totalDecks,
11:     required this.favoriteElement,
12:     required this.elementUsage,
13:   });
14: 
15:   @override
16:   Widget build(BuildContext context) {
17:     return Padding(
18:       padding: const EdgeInsets.symmetric(horizontal: 16.0),
19:       child: Card(
20:         child: Padding(
21:           padding: const EdgeInsets.all(16.0),
22:           child: Column(
23:             children: [
24:               _buildStatRow(
25:                 context,
26:                 'Total Decks',
27:                 totalDecks.toString(),
28:               ),
29:               if (favoriteElement != null) ...[
30:                 const Divider(),
31:                 _buildStatRow(
32:                   context,
33:                   'Favorite Element',
34:                   favoriteElement!,
35:                 ),
36:               ],
37:               const Divider(),
38:               const Text('Element Usage'),
39:               const SizedBox(height: 8),
40:               ...elementUsage.entries.map((entry) {
41:                 return Padding(
42:                   padding: const EdgeInsets.symmetric(vertical: 4.0),
43:                   child: LinearProgressIndicator(
44:                     value: entry.value / totalDecks,
45:                     backgroundColor:
46:                         Theme.of(context).colorScheme.surfaceContainerHighest,
47:                     valueColor: AlwaysStoppedAnimation<Color>(
48:                       Theme.of(context).colorScheme.primary,
49:                     ),
50:                   ),
51:                 );
52:               }),
53:             ],
54:           ),
55:         ),
56:       ),
57:     );
58:   }
59: 
60:   Widget _buildStatRow(BuildContext context, String label, String value) {
61:     return Padding(
62:       padding: const EdgeInsets.symmetric(vertical: 8.0),
63:       child: Row(
64:         mainAxisAlignment: MainAxisAlignment.spaceBetween,
65:         children: [
66:           Text(label),
67:           Text(
68:             value,
69:             style: Theme.of(context).textTheme.titleMedium,
70:           ),
71:         ],
72:       ),
73:     );
74:   }
75: }
</file>

<file path="lib/features/profile/presentation/widgets/profile_header.dart">
 1: import 'package:flutter/material.dart';
 2: 
 3: class ProfileHeader extends StatelessWidget {
 4:   final String userName;
 5:   final String? email;
 6:   final String? avatarUrl;
 7: 
 8:   const ProfileHeader({
 9:     super.key,
10:     required this.userName,
11:     this.email,
12:     this.avatarUrl,
13:   });
14: 
15:   @override
16:   Widget build(BuildContext context) {
17:     return Padding(
18:       padding: const EdgeInsets.all(16.0),
19:       child: Row(
20:         children: [
21:           CircleAvatar(
22:             radius: 40,
23:             backgroundImage:
24:                 avatarUrl != null ? NetworkImage(avatarUrl!) : null,
25:             child: avatarUrl == null
26:                 ? Icon(Icons.person,
27:                     size: 40, color: Theme.of(context).colorScheme.onPrimary)
28:                 : null,
29:           ),
30:           const SizedBox(width: 16),
31:           Expanded(
32:             child: Column(
33:               crossAxisAlignment: CrossAxisAlignment.start,
34:               children: [
35:                 Text(
36:                   userName,
37:                   style: Theme.of(context).textTheme.headlineSmall,
38:                 ),
39:                 if (email != null)
40:                   Text(
41:                     email!,
42:                     style: Theme.of(context).textTheme.bodyMedium,
43:                   ),
44:               ],
45:             ),
46:           ),
47:         ],
48:       ),
49:     );
50:   }
51: }
</file>

<file path="lib/features/profile/providers/user_stats_provider.dart">
1: import 'package:flutter_riverpod/flutter_riverpod.dart';
2: import '../models/user_stats.dart';
3: 
4: final userStatsProvider = StateProvider<UserStats>((ref) {
5:   return const UserStats();
6: });
</file>

<file path="lib/features/scanner/presentation/screens/scanner_screen.dart">
 1: import 'package:flutter/material.dart';
 2: import '../../../../core/presentation/widgets/app_drawer.dart';
 3: 
 4: class ScannerScreen extends StatelessWidget {
 5:   const ScannerScreen({super.key});
 6: 
 7:   @override
 8:   Widget build(BuildContext context) {
 9:     return Scaffold(
10:       appBar: AppBar(title: const Text('Card Scanner')),
11:       drawer: const AppDrawer(currentRoute: '/scanner'),
12:       body: const Center(
13:         child: Text('Scanner Screen - Coming Soon'),
14:       ),
15:     );
16:   }
17: }
</file>

<file path="lib/features/settings/presentation/screens/logs_viewer_screen.dart">
  1: import 'package:flutter/material.dart';
  2: import 'package:flutter_riverpod/flutter_riverpod.dart';
  3: import '../../../../core/logging/logger_service.dart';
  4: import 'package:share_plus/share_plus.dart';
  5: import 'dart:io';
  6: import 'package:path_provider/path_provider.dart';
  7: 
  8: class LogsViewerScreen extends ConsumerStatefulWidget {
  9:   const LogsViewerScreen({super.key});
 10: 
 11:   @override
 12:   ConsumerState<LogsViewerScreen> createState() => _LogsViewerScreenState();
 13: }
 14: 
 15: class _LogsViewerScreenState extends ConsumerState<LogsViewerScreen> {
 16:   final LoggerService _logger = LoggerService();
 17:   final ScrollController _scrollController = ScrollController();
 18:   String _logs = '';
 19:   bool _showErrorLogsOnly = false;
 20:   bool _isLoading = true;
 21: 
 22:   @override
 23:   void initState() {
 24:     super.initState();
 25:     _loadLogs();
 26:   }
 27: 
 28:   Future<void> _loadLogs() async {
 29:     setState(() => _isLoading = true);
 30:     final logs = await _logger.getLogs(errorLogsOnly: _showErrorLogsOnly);
 31:     if (mounted) {
 32:       setState(() {
 33:         _logs = logs;
 34:         _isLoading = false;
 35:       });
 36:     }
 37:   }
 38: 
 39:   Future<void> _shareLogs() async {
 40:     try {
 41:       final logs = await _logger.getLogs(errorLogsOnly: _showErrorLogsOnly);
 42:       final tempDir = await getTemporaryDirectory();
 43:       final file = File('${tempDir.path}/fftcg_companion_logs.txt');
 44:       await file.writeAsString(logs);
 45: 
 46:       await Share.shareXFiles(
 47:         [XFile(file.path)],
 48:         subject: 'FFTCG Companion Logs',
 49:       );
 50:     } catch (e) {
 51:       if (mounted) {
 52:         ScaffoldMessenger.of(context).showSnackBar(
 53:           SnackBar(content: Text('Failed to share logs: $e')),
 54:         );
 55:       }
 56:     }
 57:   }
 58: 
 59:   Future<void> _clearLogs() async {
 60:     final confirmed = await showDialog<bool>(
 61:       context: context,
 62:       builder: (context) => AlertDialog(
 63:         title: const Text('Clear Logs'),
 64:         content: const Text('Are you sure you want to clear all logs?'),
 65:         actions: [
 66:           TextButton(
 67:             onPressed: () => Navigator.pop(context, false),
 68:             child: const Text('Cancel'),
 69:           ),
 70:           TextButton(
 71:             onPressed: () => Navigator.pop(context, true),
 72:             child: const Text('Clear'),
 73:           ),
 74:         ],
 75:       ),
 76:     );
 77: 
 78:     if (confirmed == true) {
 79:       await _logger.clearLogs(errorLogsOnly: _showErrorLogsOnly);
 80:       await _loadLogs();
 81:     }
 82:   }
 83: 
 84:   @override
 85:   Widget build(BuildContext context) {
 86:     return Scaffold(
 87:       appBar: AppBar(
 88:         title: const Text('App Logs'),
 89:         actions: [
 90:           IconButton(
 91:             icon: const Icon(Icons.share),
 92:             onPressed: _shareLogs,
 93:           ),
 94:           IconButton(
 95:             icon: const Icon(Icons.delete),
 96:             onPressed: _clearLogs,
 97:           ),
 98:           IconButton(
 99:             icon: const Icon(Icons.refresh),
100:             onPressed: _loadLogs,
101:           ),
102:         ],
103:       ),
104:       body: Column(
105:         children: [
106:           Padding(
107:             padding: const EdgeInsets.all(8.0),
108:             child: Row(
109:               children: [
110:                 const Text('Show Error Logs Only'),
111:                 const SizedBox(width: 8),
112:                 Switch(
113:                   value: _showErrorLogsOnly,
114:                   onChanged: _isLoading
115:                       ? null
116:                       : (value) {
117:                           setState(() => _showErrorLogsOnly = value);
118:                           _loadLogs();
119:                         },
120:                 ),
121:               ],
122:             ),
123:           ),
124:           Expanded(
125:             child: _isLoading
126:                 ? const Center(child: CircularProgressIndicator())
127:                 : SingleChildScrollView(
128:                     controller: _scrollController,
129:                     padding: const EdgeInsets.all(16),
130:                     child: SelectableText(
131:                       _logs,
132:                       style: const TextStyle(
133:                         fontFamily: 'monospace',
134:                         fontSize: 12,
135:                       ),
136:                     ),
137:                   ),
138:           ),
139:           Padding(
140:             padding: const EdgeInsets.all(8.0),
141:             child: Row(
142:               mainAxisAlignment: MainAxisAlignment.end,
143:               children: [
144:                 FloatingActionButton(
145:                   key: const Key('scroll_up'),
146:                   heroTag: 'scroll_up_fab', // Add unique hero tag
147:                   mini: true,
148:                   onPressed: () {
149:                     _scrollController.animateTo(
150:                       0,
151:                       duration: const Duration(milliseconds: 300),
152:                       curve: Curves.easeOut,
153:                     );
154:                   },
155:                   child: const Icon(Icons.arrow_upward),
156:                 ),
157:                 const SizedBox(width: 8),
158:                 FloatingActionButton(
159:                   key: const Key('scroll_down'),
160:                   heroTag: 'scroll_down_fab', // Add unique hero tag
161:                   mini: true,
162:                   onPressed: () {
163:                     _scrollController.animateTo(
164:                       _scrollController.position.maxScrollExtent,
165:                       duration: const Duration(milliseconds: 300),
166:                       curve: Curves.easeOut,
167:                     );
168:                   },
169:                   child: const Icon(Icons.arrow_downward),
170:                 ),
171:               ],
172:             ),
173:           ),
174:         ],
175:       ),
176:     );
177:   }
178: }
</file>

<file path="lib/features/settings/presentation/screens/offline_management_screen.dart">
  1: import 'package:flutter/material.dart';
  2: import 'package:flutter_riverpod/flutter_riverpod.dart';
  3: import '../../../../core/services/sync_service.dart';
  4: import '../../../../core/logging/logger_service.dart';
  5: import '../widgets/sync_status_card.dart';
  6: import '../widgets/sync_action_card.dart';
  7: import '../widgets/offline_storage_info.dart';
  8: import '../widgets/sync_progress_indicator.dart';
  9: 
 10: class OfflineManagementScreen extends ConsumerStatefulWidget {
 11:   const OfflineManagementScreen({super.key});
 12: 
 13:   @override
 14:   ConsumerState<OfflineManagementScreen> createState() => _OfflineManagementScreenState();
 15: }
 16: 
 17: class _OfflineManagementScreenState extends ConsumerState<OfflineManagementScreen> {
 18:   final LoggerService _logger = LoggerService();
 19:   bool _isSyncing = false;
 20: 
 21:   Future<void> _handleManualSync() async {
 22:     if (_isSyncing) return;
 23: 
 24:     setState(() => _isSyncing = true);
 25:     try {
 26:       _logger.info('Starting manual sync');
 27:       await ref.read(syncServiceProvider).syncPendingChanges();
 28:       if (mounted) {
 29:         ScaffoldMessenger.of(context).showSnackBar(
 30:           const SnackBar(content: Text('Sync completed successfully')),
 31:         );
 32:       }
 33:       _logger.info('Manual sync completed');
 34:     } catch (e) {
 35:       _logger.severe('Manual sync failed', e);
 36:       if (mounted) {
 37:         ScaffoldMessenger.of(context).showSnackBar(
 38:           SnackBar(
 39:             content: const Text('Sync failed. Please try again.'),
 40:             action: SnackBarAction(
 41:               label: 'Retry',
 42:               onPressed: _handleManualSync,
 43:             ),
 44:           ),
 45:         );
 46:       }
 47:     } finally {
 48:       if (mounted) {
 49:         setState(() => _isSyncing = false);
 50:       }
 51:     }
 52:   }
 53: 
 54:   Future<void> _handleResetSync() async {
 55:     final confirmed = await showDialog<bool>(
 56:       context: context,
 57:       builder: (context) => AlertDialog(
 58:         title: const Text('Reset Sync Status'),
 59:         content: const Text(
 60:           'This will mark all data for re-sync. Proceed?'
 61:         ),
 62:         actions: [
 63:           TextButton(
 64:             onPressed: () => Navigator.pop(context, false),
 65:             child: const Text('Cancel'),
 66:           ),
 67:           TextButton(
 68:             onPressed: () => Navigator.pop(context, true),
 69:             child: const Text('Reset'),
 70:           ),
 71:         ],
 72:       ),
 73:     );
 74: 
 75:     if (confirmed == true) {
 76:       try {
 77:         _logger.info('Starting sync reset');
 78:         await ref.read(syncServiceProvider).resetSyncStatus();
 79:         if (mounted) {
 80:           ScaffoldMessenger.of(context).showSnackBar(
 81:             const SnackBar(content: Text('Sync status reset successfully')),
 82:           );
 83:         }
 84:         _logger.info('Sync reset completed');
 85:       } catch (e) {
 86:         _logger.severe('Sync reset failed', e);
 87:         if (mounted) {
 88:           ScaffoldMessenger.of(context).showSnackBar(
 89:             const SnackBar(content: Text('Failed to reset sync status')),
 90:           );
 91:         }
 92:       }
 93:     }
 94:   }
 95: 
 96:   @override
 97:   Widget build(BuildContext context) {
 98:     final syncStatus = ref.watch(syncStatusProvider);
 99: 
100:     return Scaffold(
101:       appBar: AppBar(
102:         title: const Text('Offline Management'),
103:         actions: [
104:           IconButton(
105:             icon: const Icon(Icons.help_outline),
106:             onPressed: () {
107:               showDialog(
108:                 context: context,
109:                 builder: (context) => AlertDialog(
110:                   title: const Text('About Offline Mode'),
111:                   content: const Text(
112:                       'Offline mode allows you to view and modify your collection '
113:                       'without an internet connection. Changes will be synchronized '
114:                       'when you\'re back online.\n\n'
115:                       'Green status indicates all data is synced.\n'
116:                       'Yellow indicates pending changes.\n'
117:                       'Red indicates sync errors.'),
118:                   actions: [
119:                     TextButton(
120:                       onPressed: () => Navigator.pop(context),
121:                       child: const Text('Got it'),
122:                     ),
123:                   ],
124:                 ),
125:               );
126:             },
127:           ),
128:         ],
129:       ),
130:       body: RefreshIndicator(
131:         onRefresh: _handleManualSync,
132:         child: ListView(
133:           padding: const EdgeInsets.all(16),
134:           children: [
135:             SyncStatusCard(
136:               syncStatus: syncStatus,
137:               onSync: _handleManualSync,
138:             ),
139:             const SizedBox(height: 16),
140:             if (_isSyncing) ...[
141:               const SyncProgressIndicator(),
142:               const SizedBox(height: 16),
143:             ],
144:             const OfflineStorageInfo(),
145:             const SizedBox(height: 16),
146:             SyncActionCard(
147:               onReset: _handleResetSync,
148:               onToggleAutoSync: (enabled) {
149:                 if (enabled) {
150:                   ref.read(syncServiceProvider).startPeriodicSync();
151:                 } else {
152:                   ref.read(syncServiceProvider).stopPeriodicSync();
153:                 }
154:               },
155:             ),
156:           ],
157:         ),
158:       ),
159:     );
160:   }
161: }
</file>

<file path="lib/features/settings/presentation/screens/settings_screen.dart">
  1: // lib/features/settings/presentation/screens/settings_screen.dart
  2: import 'package:flutter/material.dart';
  3: import 'package:flutter_riverpod/flutter_riverpod.dart';
  4: import '../widgets/theme_selector.dart';
  5: import '../widgets/color_picker.dart';
  6: import '../widgets/settings_switch_tile.dart';
  7: import '../screens/offline_management_screen.dart';
  8: import '../../providers/settings_providers.dart';
  9: 
 10: class SettingsScreen extends ConsumerWidget {
 11:   const SettingsScreen({super.key});
 12: 
 13:   @override
 14:   Widget build(BuildContext context, WidgetRef ref) {
 15:     return Scaffold(
 16:       appBar: AppBar(
 17:         title: const Text('Settings'),
 18:       ),
 19:       body: ListView(
 20:         children: const [
 21:           _ThemeSection(),
 22:           Divider(),
 23:           _PreferencesSection(),
 24:           Divider(),
 25:           _OfflineSection(),
 26:         ],
 27:       ),
 28:     );
 29:   }
 30: }
 31: 
 32: class _ThemeSection extends ConsumerWidget {
 33:   const _ThemeSection();
 34: 
 35:   @override
 36:   Widget build(BuildContext context, WidgetRef ref) {
 37:     return Column(
 38:       crossAxisAlignment: CrossAxisAlignment.start,
 39:       children: [
 40:         Padding(
 41:           padding: const EdgeInsets.all(16.0),
 42:           child: Text(
 43:             'Appearance',
 44:             style: Theme.of(context).textTheme.titleLarge,
 45:           ),
 46:         ),
 47:         const ThemeSelector(),
 48:         const ColorPicker(),
 49:       ],
 50:     );
 51:   }
 52: }
 53: 
 54: class _PreferencesSection extends ConsumerWidget {
 55:   const _PreferencesSection();
 56: 
 57:   @override
 58:   Widget build(BuildContext context, WidgetRef ref) {
 59:     return Column(
 60:       crossAxisAlignment: CrossAxisAlignment.start,
 61:       children: [
 62:         Padding(
 63:           padding: const EdgeInsets.all(16.0),
 64:           child: Text(
 65:             'Preferences',
 66:             style: Theme.of(context).textTheme.titleLarge,
 67:           ),
 68:         ),
 69:         SettingsSwitchTile(
 70:           title: 'Remember Filters',
 71:           subtitle: 'Save filter settings between sessions',
 72:           value: ref.watch(persistFiltersProvider),
 73:           onChanged: (value) {
 74:             ref
 75:                 .read(settingsNotifierProvider.notifier)
 76:                 .setPersistFilters(value);
 77:           },
 78:         ),
 79:         SettingsSwitchTile(
 80:           title: 'Remember Sort Order',
 81:           subtitle: 'Save sort settings between sessions',
 82:           value: ref.watch(persistSortProvider),
 83:           onChanged: (value) {
 84:             ref.read(settingsNotifierProvider.notifier).setPersistSort(value);
 85:           },
 86:         ),
 87:       ],
 88:     );
 89:   }
 90: }
 91: 
 92: class _OfflineSection extends ConsumerWidget {
 93:   const _OfflineSection();
 94: 
 95:   @override
 96:   Widget build(BuildContext context, WidgetRef ref) {
 97:     return Column(
 98:       crossAxisAlignment: CrossAxisAlignment.start,
 99:       children: [
100:         Padding(
101:           padding: const EdgeInsets.all(16.0),
102:           child: Text(
103:             'Offline Access',
104:             style: Theme.of(context).textTheme.titleLarge,
105:           ),
106:         ),
107:         ListTile(
108:           leading: const Icon(Icons.offline_bolt),
109:           title: const Text('Offline Management'),
110:           subtitle: const Text('Manage offline data and sync settings'),
111:           onTap: () {
112:             Navigator.push(
113:               context,
114:               MaterialPageRoute(
115:                 builder: (context) => const OfflineManagementScreen(),
116:               ),
117:             );
118:           },
119:         ),
120:       ],
121:     );
122:   }
123: }
</file>

<file path="lib/features/settings/presentation/widgets/color_picker.dart">
 1: import 'package:flutter/material.dart';
 2: import 'package:flutter_riverpod/flutter_riverpod.dart';
 3: import '../../providers/settings_providers.dart';
 4: 
 5: class ColorPicker extends ConsumerWidget {
 6:   const ColorPicker({super.key});
 7: 
 8:   static const List<Color> _colors = [
 9:     Colors.purple,
10:     Colors.blue,
11:     Colors.green,
12:     Colors.orange,
13:     Colors.red,
14:     Colors.pink,
15:   ];
16: 
17:   @override
18:   Widget build(BuildContext context, WidgetRef ref) {
19:     final selectedColor = ref.watch(themeColorProvider);
20: 
21:     return ListTile(
22:       title: const Text('Theme Color'),
23:       subtitle: const Text('Choose your accent color'),
24:       trailing: Wrap(
25:         children: _colors.map((color) {
26:           return Padding(
27:             padding: const EdgeInsets.all(4.0),
28:             child: GestureDetector(
29:               onTap: () {
30:                 ref
31:                     .read(settingsNotifierProvider.notifier)
32:                     .setThemeColor(color);
33:               },
34:               child: Container(
35:                 width: 32,
36:                 height: 32,
37:                 decoration: BoxDecoration(
38:                   color: color,
39:                   shape: BoxShape.circle,
40:                   border: selectedColor == color
41:                       ? Border.all(color: Colors.white, width: 2)
42:                       : null,
43:                 ),
44:               ),
45:             ),
46:           );
47:         }).toList(),
48:       ),
49:     );
50:   }
51: }
</file>

<file path="lib/features/settings/presentation/widgets/offline_storage_info.dart">
  1: import 'package:flutter/material.dart';
  2: import 'package:flutter_riverpod/flutter_riverpod.dart';
  3: import '../../../../core/services/sync_service.dart';
  4: import 'package:shared_preferences/shared_preferences.dart';
  5: 
  6: class OfflineStorageInfo extends ConsumerStatefulWidget {
  7:   const OfflineStorageInfo({super.key});
  8: 
  9:   @override
 10:   ConsumerState<OfflineStorageInfo> createState() => _OfflineStorageInfoState();
 11: }
 12: 
 13: class _OfflineStorageInfoState extends ConsumerState<OfflineStorageInfo> {
 14:   String _lastSyncTime = 'Never';
 15: 
 16:   @override
 17:   void initState() {
 18:     super.initState();
 19:     _loadLastSyncTime();
 20:   }
 21: 
 22:   Future<void> _loadLastSyncTime() async {
 23:     final prefs = await SharedPreferences.getInstance();
 24:     final lastSync = prefs.getInt('last_sync_timestamp');
 25:     if (lastSync != null) {
 26:       final date = DateTime.fromMillisecondsSinceEpoch(lastSync);
 27:       setState(() {
 28:         _lastSyncTime = _formatLastSync(date);
 29:       });
 30:     }
 31:   }
 32: 
 33:   String _formatLastSync(DateTime date) {
 34:     final now = DateTime.now();
 35:     final difference = now.difference(date);
 36: 
 37:     if (difference.inMinutes < 1) {
 38:       return 'Just now';
 39:     } else if (difference.inHours < 1) {
 40:       return '${difference.inMinutes}m ago';
 41:     } else if (difference.inDays < 1) {
 42:       return '${difference.inHours}h ago';
 43:     } else {
 44:       return '${difference.inDays}d ago';
 45:     }
 46:   }
 47: 
 48:   @override
 49:   Widget build(BuildContext context) {
 50:     final cardCount = ref.watch(syncServiceProvider).getCardCount();
 51: 
 52:     return Card(
 53:       child: Padding(
 54:         padding: const EdgeInsets.all(16),
 55:         child: Column(
 56:           crossAxisAlignment: CrossAxisAlignment.start,
 57:           children: [
 58:             const Text(
 59:               'Offline Storage',
 60:               style: TextStyle(
 61:                 fontSize: 18,
 62:                 fontWeight: FontWeight.bold,
 63:               ),
 64:             ),
 65:             const SizedBox(height: 16),
 66:             _buildInfoRow(
 67:               context,
 68:               'Cards Stored',
 69:               '$cardCount cards',
 70:               Icons.storage,
 71:             ),
 72:             const SizedBox(height: 8),
 73:             _buildInfoRow(
 74:               context,
 75:               'Last Sync',
 76:               _lastSyncTime,
 77:               Icons.access_time,
 78:             ),
 79:           ],
 80:         ),
 81:       ),
 82:     );
 83:   }
 84: 
 85:   Widget _buildInfoRow(
 86:     BuildContext context,
 87:     String label,
 88:     String value,
 89:     IconData icon,
 90:   ) {
 91:     return Row(
 92:       children: [
 93:         Icon(icon, size: 20),
 94:         const SizedBox(width: 8),
 95:         Text(
 96:           label,
 97:           style: Theme.of(context).textTheme.bodyLarge,
 98:         ),
 99:         const Spacer(),
100:         Text(
101:           value,
102:           style: Theme.of(context).textTheme.bodyMedium,
103:         ),
104:       ],
105:     );
106:   }
107: }
</file>

<file path="lib/features/settings/presentation/widgets/settings_switch_tile.dart">
 1: import 'package:flutter/material.dart';
 2: 
 3: class SettingsSwitchTile extends StatelessWidget {
 4:   final String title;
 5:   final String subtitle;
 6:   final bool value;
 7:   final ValueChanged<bool> onChanged;
 8: 
 9:   const SettingsSwitchTile({
10:     super.key,
11:     required this.title,
12:     required this.subtitle,
13:     required this.value,
14:     required this.onChanged,
15:   });
16: 
17:   @override
18:   Widget build(BuildContext context) {
19:     return SwitchListTile(
20:       title: Text(title),
21:       subtitle: Text(subtitle),
22:       value: value,
23:       onChanged: onChanged,
24:     );
25:   }
26: }
</file>

<file path="lib/features/settings/presentation/widgets/sync_action_card.dart">
 1: import 'package:flutter/material.dart';
 2: 
 3: class SyncActionCard extends StatelessWidget {
 4:   final VoidCallback onReset;
 5:   final ValueChanged<bool> onToggleAutoSync;
 6: 
 7:   const SyncActionCard({
 8:     super.key,
 9:     required this.onReset,
10:     required this.onToggleAutoSync,
11:   });
12: 
13:   @override
14:   Widget build(BuildContext context) {
15:     return Card(
16:       child: Padding(
17:         padding: const EdgeInsets.all(16),
18:         child: Column(
19:           crossAxisAlignment: CrossAxisAlignment.start,
20:           children: [
21:             const Text(
22:               'Sync Settings',
23:               style: TextStyle(
24:                 fontSize: 18,
25:                 fontWeight: FontWeight.bold,
26:               ),
27:             ),
28:             const SizedBox(height: 16),
29:             SwitchListTile(
30:               title: const Text('Auto-sync'),
31:               subtitle: const Text(
32:                 'Automatically sync changes when online',
33:               ),
34:               value: true, // TODO: Get from preferences
35:               onChanged: onToggleAutoSync,
36:             ),
37:             const Divider(),
38:             ListTile(
39:               leading: const Icon(Icons.restore),
40:               title: const Text('Reset Sync Status'),
41:               subtitle: const Text(
42:                 'Mark all data for re-synchronization',
43:               ),
44:               onTap: onReset,
45:             ),
46:           ],
47:         ),
48:       ),
49:     );
50:   }
51: }
</file>

<file path="lib/features/settings/presentation/widgets/sync_progress_indicator.dart">
 1: import 'package:flutter/material.dart';
 2: 
 3: class SyncProgressIndicator extends StatelessWidget {
 4:   const SyncProgressIndicator({super.key});
 5: 
 6:   @override
 7:   Widget build(BuildContext context) {
 8:     return Card(
 9:       child: Padding(
10:         padding: const EdgeInsets.all(16),
11:         child: Column(
12:           crossAxisAlignment: CrossAxisAlignment.start,
13:           children: [
14:             Row(
15:               children: [
16:                 const SizedBox(
17:                   width: 20,
18:                   height: 20,
19:                   child: CircularProgressIndicator(strokeWidth: 2),
20:                 ),
21:                 const SizedBox(width: 16),
22:                 Text(
23:                   'Syncing...',
24:                   style: Theme.of(context).textTheme.titleMedium,
25:                 ),
26:               ],
27:             ),
28:             const SizedBox(height: 16),
29:             const LinearProgressIndicator(),
30:             const SizedBox(height: 8),
31:             Text(
32:               'Please keep the app open',
33:               style: Theme.of(context).textTheme.bodySmall,
34:             ),
35:           ],
36:         ),
37:       ),
38:     );
39:   }
40: }
</file>

<file path="lib/features/settings/presentation/widgets/sync_status_card.dart">
 1: import 'package:flutter/material.dart';
 2: import 'package:flutter_riverpod/flutter_riverpod.dart';
 3: 
 4: class SyncStatusCard extends ConsumerWidget {
 5:   final AsyncValue<bool> syncStatus;
 6:   final VoidCallback onSync;
 7: 
 8:   const SyncStatusCard({
 9:     super.key,
10:     required this.syncStatus,
11:     required this.onSync,
12:   });
13: 
14:   @override
15:   Widget build(BuildContext context, WidgetRef ref) {
16:     return Card(
17:       child: Padding(
18:         padding: const EdgeInsets.all(16),
19:         child: Column(
20:           crossAxisAlignment: CrossAxisAlignment.start,
21:           children: [
22:             Row(
23:               children: [
24:                 const Icon(Icons.sync),
25:                 const SizedBox(width: 8),
26:                 const Text(
27:                   'Sync Status',
28:                   style: TextStyle(
29:                     fontSize: 18,
30:                     fontWeight: FontWeight.bold,
31:                   ),
32:                 ),
33:                 const Spacer(),
34:                 _buildStatusIcon(syncStatus),
35:               ],
36:             ),
37:             const SizedBox(height: 16),
38:             _buildStatusMessage(syncStatus),
39:             const SizedBox(height: 16),
40:             SizedBox(
41:               width: double.infinity,
42:               child: ElevatedButton(
43:                 onPressed: syncStatus.isLoading ? null : onSync,
44:                 child: const Text('Sync Now'),
45:               ),
46:             ),
47:           ],
48:         ),
49:       ),
50:     );
51:   }
52: 
53:   Widget _buildStatusIcon(AsyncValue<bool> status) {
54:     return status.when(
55:       data: (isSynced) => Icon(
56:         isSynced ? Icons.check_circle : Icons.warning,
57:         color: isSynced ? Colors.green : Colors.orange,
58:       ),
59:       loading: () => const SizedBox(
60:         width: 24,
61:         height: 24,
62:         child: CircularProgressIndicator(strokeWidth: 2),
63:       ),
64:       error: (_, __) => const Icon(
65:         Icons.error,
66:         color: Colors.red,
67:       ),
68:     );
69:   }
70: 
71:   Widget _buildStatusMessage(AsyncValue<bool> status) {
72:     return status.when(
73:       data: (isSynced) => Text(
74:         isSynced
75:             ? 'All data is synchronized'
76:             : 'Some changes need to be synced',
77:         style: TextStyle(
78:           color: isSynced ? Colors.green : Colors.orange,
79:         ),
80:       ),
81:       loading: () => const Text('Checking sync status...'),
82:       error: (error, _) => Text(
83:         'Error checking sync status: $error',
84:         style: const TextStyle(color: Colors.red),
85:       ),
86:     );
87:   }
88: }
</file>

<file path="lib/features/settings/presentation/widgets/theme_selector.dart">
 1: import 'package:flutter/material.dart';
 2: import 'package:flutter_riverpod/flutter_riverpod.dart';
 3: import '../../providers/settings_providers.dart';
 4: 
 5: class ThemeSelector extends ConsumerWidget {
 6:   const ThemeSelector({super.key});
 7: 
 8:   @override
 9:   Widget build(BuildContext context, WidgetRef ref) {
10:     final themeMode = ref.watch(themeModeProvider);
11: 
12:     return ListTile(
13:       title: const Text('Theme Mode'),
14:       subtitle: const Text('Choose your preferred theme'),
15:       trailing: DropdownButton<ThemeMode>(
16:         value: themeMode,
17:         onChanged: (ThemeMode? newMode) {
18:           if (newMode != null) {
19:             ref.read(settingsNotifierProvider.notifier).setThemeMode(newMode);
20:           }
21:         },
22:         items: const [
23:           DropdownMenuItem(
24:             value: ThemeMode.system,
25:             child: Text('System'),
26:           ),
27:           DropdownMenuItem(
28:             value: ThemeMode.light,
29:             child: Text('Light'),
30:           ),
31:           DropdownMenuItem(
32:             value: ThemeMode.dark,
33:             child: Text('Dark'),
34:           ),
35:         ],
36:       ),
37:     );
38:   }
39: }
</file>

<file path="lib/features/settings/providers/settings_providers.dart">
 1: import 'package:flutter/material.dart';
 2: import 'package:flutter_riverpod/flutter_riverpod.dart';
 3: 
 4: final themeModeProvider = StateProvider<ThemeMode>((ref) => ThemeMode.system);
 5: 
 6: final themeColorProvider = StateProvider<Color>((ref) => Colors.purple);
 7: 
 8: final persistFiltersProvider = StateProvider<bool>((ref) => true);
 9: 
10: final persistSortProvider = StateProvider<bool>((ref) => true);
11: 
12: final settingsNotifierProvider =
13:     StateNotifierProvider<SettingsNotifier, SettingsState>((ref) {
14:   return SettingsNotifier();
15: });
16: 
17: class SettingsState {
18:   final ThemeMode themeMode;
19:   final Color themeColor;
20:   final bool persistFilters;
21:   final bool persistSort;
22: 
23:   SettingsState({
24:     this.themeMode = ThemeMode.system,
25:     this.themeColor = Colors.purple,
26:     this.persistFilters = true,
27:     this.persistSort = true,
28:   });
29: }
30: 
31: class SettingsNotifier extends StateNotifier<SettingsState> {
32:   SettingsNotifier() : super(SettingsState());
33: 
34:   void setThemeMode(ThemeMode mode) {
35:     state = SettingsState(
36:       themeMode: mode,
37:       themeColor: state.themeColor,
38:       persistFilters: state.persistFilters,
39:       persistSort: state.persistSort,
40:     );
41:   }
42: 
43:   void setThemeColor(Color color) {
44:     state = SettingsState(
45:       themeMode: state.themeMode,
46:       themeColor: color,
47:       persistFilters: state.persistFilters,
48:       persistSort: state.persistSort,
49:     );
50:   }
51: 
52:   void setPersistFilters(bool value) {
53:     state = SettingsState(
54:       themeMode: state.themeMode,
55:       themeColor: state.themeColor,
56:       persistFilters: value,
57:       persistSort: state.persistSort,
58:     );
59:   }
60: 
61:   void setPersistSort(bool value) {
62:     state = SettingsState(
63:       themeMode: state.themeMode,
64:       themeColor: state.themeColor,
65:       persistFilters: state.persistFilters,
66:       persistSort: value,
67:     );
68:   }
69: }
</file>

<file path="lib/main.dart">
  1: import 'package:firebase_core/firebase_core.dart';
  2: import 'package:firebase_app_check/firebase_app_check.dart';
  3: import 'package:flutter/material.dart';
  4: import 'package:flutter/foundation.dart';
  5: import 'package:flutter_riverpod/flutter_riverpod.dart';
  6: import 'package:shared_preferences/shared_preferences.dart';
  7: import 'package:connectivity_plus/connectivity_plus.dart';
  8: 
  9: import 'core/logging/logger_service.dart';
 10: import 'core/theme/app_theme.dart';
 11: import 'features/cards/providers/card_providers.dart';
 12: import 'firebase_options.dart';
 13: import 'core/providers/app_providers.dart';
 14: import 'features/auth/presentation/auth_wrapper.dart';
 15: import 'features/cards/presentation/screens/cards_screen.dart';
 16: import 'features/collection/presentation/screens/collection_screen.dart';
 17: import 'features/decks/presentation/screens/decks_screen.dart';
 18: import 'features/scanner/presentation/screens/scanner_screen.dart';
 19: import 'features/profile/presentation/screens/profile_screen.dart';
 20: import 'features/settings/presentation/screens/settings_screen.dart';
 21: 
 22: void main() async {
 23:   WidgetsFlutterBinding.ensureInitialized();
 24: 
 25:   // Set up error handling
 26:   FlutterError.onError = (FlutterErrorDetails details) {
 27:     FlutterError.presentError(details);
 28:     debugPrint('Error: ${details.exception}');
 29:     debugPrint('Stack trace: ${details.stack}');
 30:   };
 31: 
 32:   // Handle errors not caught by Flutter
 33:   PlatformDispatcher.instance.onError = (error, stack) {
 34:     debugPrint('Error: $error');
 35:     debugPrint('Stack trace: $stack');
 36:     return true;
 37:   };
 38: 
 39:   try {
 40:     final logger = LoggerService();
 41: 
 42:     // Initialize SharedPreferences
 43:     final sharedPrefs = await SharedPreferences.getInstance();
 44: 
 45:     // Create ProviderContainer with overrides
 46:     final container = ProviderContainer(
 47:       overrides: [
 48:         sharedPreferencesProvider.overrideWithValue(sharedPrefs),
 49:       ],
 50:     );
 51: 
 52:     // Initialize Firebase and App Check
 53:     await _initializeFirebase(logger);
 54: 
 55:     // Run the app with ProviderScope and ErrorWidget customization
 56:     ErrorWidget.builder = (FlutterErrorDetails details) {
 57:       return Material(
 58:         child: Container(
 59:           color: Colors.white,
 60:           child: Center(
 61:             child: Text(
 62:               'An error occurred: ${details.exception}',
 63:               style: const TextStyle(color: Colors.red),
 64:             ),
 65:           ),
 66:         ),
 67:       );
 68:     };
 69: 
 70:     runApp(
 71:       UncontrolledProviderScope(
 72:         container: container,
 73:         child: const FFTCGCompanionApp(),
 74:       ),
 75:     );
 76:   } catch (e, stackTrace) {
 77:     debugPrint('Initialization error: $e');
 78:     debugPrint('Stack trace: $stackTrace');
 79:     runApp(
 80:       MaterialApp(
 81:         home: ErrorScreen(
 82:           error: e.toString(),
 83:           onRetry: () => main(),
 84:         ),
 85:       ),
 86:     );
 87:   }
 88: }
 89: 
 90: // Create a simple error screen widget
 91: class ErrorScreen extends StatelessWidget {
 92:   final String error;
 93:   final VoidCallback onRetry;
 94: 
 95:   const ErrorScreen({
 96:     super.key,
 97:     required this.error,
 98:     required this.onRetry,
 99:   });
100: 
101:   @override
102:   Widget build(BuildContext context) {
103:     return MaterialApp(
104:       home: Scaffold(
105:         body: Center(
106:           child: Padding(
107:             padding: const EdgeInsets.all(16.0),
108:             child: Column(
109:               mainAxisAlignment: MainAxisAlignment.center,
110:               children: [
111:                 const Icon(
112:                   Icons.error_outline,
113:                   color: Colors.red,
114:                   size: 48,
115:                 ),
116:                 const SizedBox(height: 16),
117:                 Text(
118:                   'Error',
119:                   style: Theme.of(context).textTheme.headlineMedium,
120:                 ),
121:                 const SizedBox(height: 8),
122:                 Text(
123:                   error,
124:                   textAlign: TextAlign.center,
125:                 ),
126:                 const SizedBox(height: 16),
127:                 ElevatedButton.icon(
128:                   onPressed: onRetry,
129:                   icon: const Icon(Icons.refresh),
130:                   label: const Text('Retry'),
131:                 ),
132:               ],
133:             ),
134:           ),
135:         ),
136:       ),
137:     );
138:   }
139: }
140: 
141: Future<void> _initializeFirebase(LoggerService logger) async {
142:   try {
143:     // Check connectivity first
144:     final connectivity = Connectivity();
145:     final connectivityResult = await connectivity.checkConnectivity();
146:     if (connectivityResult.contains(ConnectivityResult.none)) {
147:       logger.warning('No network connectivity available');
148:     }
149: 
150:     // Initialize Firebase
151:     await Firebase.initializeApp(
152:       options: DefaultFirebaseOptions.currentPlatform,
153:     );
154: 
155:     // Initialize App Check with retry mechanism
156:     if (!kIsWeb && !kDebugMode) {
157:       // Only enable App Check in release mode
158:       await FirebaseAppCheck.instance.activate(
159:         androidProvider: AndroidProvider.playIntegrity,
160:         appleProvider: AppleProvider.appAttest,
161:       );
162:     }
163: 
164:     logger.info('Firebase initialized successfully');
165:   } catch (e, stackTrace) {
166:     logger.severe('Firebase initialization failed', e, stackTrace);
167:     rethrow;
168:   }
169: }
170: 
171: class FFTCGCompanionApp extends ConsumerWidget {
172:   const FFTCGCompanionApp({super.key});
173: 
174:   @override
175:   Widget build(BuildContext context, WidgetRef ref) {
176:     final appState = ref.watch(appStateProvider);
177: 
178:     return MaterialApp(
179:       title: 'FFTCG Companion',
180:       theme: AppTheme.darkTheme,
181:       initialRoute: '/',
182:       routes: {
183:         '/': (context) => const AuthWrapper(),
184:         '/cards': (context) => const CardsScreen(),
185:         '/collection': (context) => const CollectionScreen(),
186:         '/decks': (context) => const DecksScreen(),
187:         '/scanner': (context) => const ScannerScreen(),
188:         '/profile': (context) => const ProfileScreen(),
189:         '/settings': (context) => const SettingsScreen(),
190:       },
191:       builder: (context, child) {
192:         // Handle null child
193:         if (child == null) {
194:           return const Material(
195:             child: Center(
196:               child: Text('Loading...'),
197:             ),
198:           );
199:         }
200: 
201:         // Wrap the child with error handling
202:         return Material(
203:           child: Column(
204:             children: [
205:               if (appState.isOnline == false)
206:                 Container(
207:                   color: Colors.red,
208:                   padding: const EdgeInsets.all(4),
209:                   child: const Text(
210:                     'Offline Mode',
211:                     textAlign: TextAlign.center,
212:                     style: TextStyle(color: Colors.white),
213:                   ),
214:                 ),
215:               Expanded(child: child),
216:             ],
217:           ),
218:         );
219:       },
220:       debugShowCheckedModeBanner: false,
221:     );
222:   }
223: }
</file>

<file path="lib/models/user_model.dart">
 1: import 'package:cloud_firestore/cloud_firestore.dart';
 2: import 'dart:convert';
 3: 
 4: class UserModel {
 5:   final String id;
 6:   final String? email;
 7:   final String? displayName;
 8:   final String? photoURL;
 9:   final bool isGuest;
10:   final bool isEmailVerified;
11:   final DateTime createdAt;
12:   final DateTime lastLoginAt;
13: 
14:   UserModel({
15:     required this.id,
16:     this.email,
17:     this.displayName,
18:     this.photoURL,
19:     this.isGuest = false,
20:     this.isEmailVerified = false,
21:     DateTime? createdAt,
22:     DateTime? lastLoginAt,
23:   })  : createdAt = createdAt ?? DateTime.now(),
24:         lastLoginAt = lastLoginAt ?? DateTime.now();
25: 
26:   factory UserModel.fromFirestore(DocumentSnapshot doc) {
27:     final data = doc.data() as Map<String, dynamic>;
28:     return UserModel(
29:       id: doc.id,
30:       email: data['email'],
31:       displayName: data['displayName'],
32:       photoURL: data['photoURL'],
33:       isGuest: data['isGuest'] ?? false,
34:       isEmailVerified: data['isEmailVerified'] ?? false,
35:       createdAt: data['createdAt'] is Timestamp
36:           ? (data['createdAt'] as Timestamp).toDate()
37:           : data['createdAt'] is String
38:               ? DateTime.parse(data['createdAt'])
39:               : DateTime.now(),
40:       lastLoginAt: data['lastLoginAt'] is Timestamp
41:           ? (data['lastLoginAt'] as Timestamp).toDate()
42:           : data['lastLoginAt'] is String
43:               ? DateTime.parse(data['lastLoginAt'])
44:               : DateTime.now(),
45:     );
46:   }
47: 
48:   Map<String, dynamic> toMap() {
49:     return {
50:       'id': id,
51:       'email': email,
52:       'displayName': displayName,
53:       'photoURL': photoURL,
54:       'isGuest': isGuest,
55:       'isEmailVerified': isEmailVerified,
56:       'createdAt': Timestamp.fromDate(createdAt),
57:       'lastLoginAt': Timestamp.fromDate(lastLoginAt),
58:     };
59:   }
60: 
61:   String toJson() => json.encode(toMap());
62: 
63:   factory UserModel.fromJson(String jsonString) {
64:     final Map<String, dynamic> data = json.decode(jsonString);
65:     return UserModel(
66:       id: data['id'],
67:       email: data['email'],
68:       displayName: data['displayName'],
69:       photoURL: data['photoURL'],
70:       isGuest: data['isGuest'] ?? false,
71:       isEmailVerified: data['isEmailVerified'] ?? false,
72:       createdAt: DateTime.parse(data['createdAt']),
73:       lastLoginAt: DateTime.parse(data['lastLoginAt']),
74:     );
75:   }
76: }
</file>

<file path="lib/services/firebase_service.dart">
 1: import 'package:cloud_firestore/cloud_firestore.dart';
 2: import 'package:firebase_storage/firebase_storage.dart';
 3: import 'package:flutter_riverpod/flutter_riverpod.dart';
 4: import 'package:logging/logging.dart';
 5: import 'package:flutter/foundation.dart';
 6: 
 7: final firebaseServiceProvider = Provider((ref) => FirebaseService());
 8: 
 9: class FirebaseService {
10:   final FirebaseFirestore _firestore = FirebaseFirestore.instance;
11:   final FirebaseStorage _storage = FirebaseStorage.instance;
12:   final _logger = Logger('FirebaseService');
13: 
14:   FirebaseService() {
15:     Logger.root.level = Level.ALL;
16:     Logger.root.onRecord.listen((record) {
17:       // In development, you might want to print to console
18:       // In production, this could be integrated with a proper logging service
19:       debugPrint('${record.level.name}: ${record.time}: ${record.message}');
20:     });
21:   }
22: 
23:   // Collection reference
24:   CollectionReference get cards => _firestore.collection('cards');
25: 
26:   // Test query to verify connection
27:   Future<bool> testConnection() async {
28:     try {
29:       final snapshot = await cards.limit(1).get();
30:       return snapshot.docs.isNotEmpty;
31:     } catch (e) {
32:       _logger.severe('Firebase connection error: $e');
33:       return false;
34:     }
35:   }
36: 
37:   // Get card by ID
38:   Future<DocumentSnapshot?> getCard(String cardId) async {
39:     try {
40:       return await cards.doc(cardId).get();
41:     } catch (e) {
42:       _logger.severe('Error getting card: $e');
43:       return null;
44:     }
45:   }
46: 
47:   // Get paginated cards
48:   Future<QuerySnapshot> getCards({
49:     DocumentSnapshot? startAfter,
50:     int limit = 20,
51:   }) async {
52:     try {
53:       Query query = cards.orderBy('name').limit(limit);
54: 
55:       if (startAfter != null) {
56:         query = query.startAfterDocument(startAfter);
57:       }
58: 
59:       return await query.get();
60:     } catch (e) {
61:       _logger.severe('Error getting cards: $e');
62:       rethrow;
63:     }
64:   }
65: 
66:   // Get image URL
67:   String getImageUrl(String path) {
68:     try {
69:       return _storage.ref(path).getDownloadURL().toString();
70:     } catch (e) {
71:       _logger.severe('Error getting image URL: $e');
72:       return '';
73:     }
74:   }
75: }
</file>

<file path="pubspec.yaml">
 1: name: fftcg_companion_app
 2: description: A companion app for Final Fantasy Trading Card Game
 3: publish_to: 'none'
 4: version: 1.0.0+1
 5: 
 6: environment:
 7:   sdk: '>=3.2.0 <4.0.0'
 8: 
 9: dependencies:
10:   flutter:
11:     sdk: flutter
12:   firebase_core: ^3.8.1
13:   cloud_firestore: ^5.5.1
14:   firebase_storage: ^12.3.7
15:   cached_network_image: ^3.3.0
16:   hive: ^2.2.3
17:   hive_flutter: ^1.1.0
18:   flutter_riverpod: ^2.4.9
19:   go_router: ^13.0.0
20:   workmanager: ^0.5.1
21:   flutter_staggered_grid_view: ^0.7.0
22:   json_annotation: ^4.8.1
23:   freezed_annotation: ^2.4.4
24:   logging: ^1.2.0    
25:   path_provider: ^2.1.1
26:   share_plus: ^7.2.1
27:   shared_preferences: ^2.3.3
28:   firebase_app_check: 0.3.1+7
29:   connectivity_plus: ^6.1.0
30:   flutter_launcher_icons: ^0.14.2
31:   internet_connection_checker: ^1.0.0+1
32:   firebase_crashlytics: ^4.2.0
33:   device_info_plus: ^9.1.1
34:   google_api_availability: 5.0.0
35:   google_sign_in: ^6.2.2
36:   firebase_auth: ^5.3.4
37:   
38: 
39: dev_dependencies:
40:   flutter_test:
41:     sdk: flutter
42:   flutter_lints: ^3.0.1
43:   build_runner: ^2.4.14
44:   json_serializable: ^6.7.1
45:   freezed: ^2.5.7
46:   hive_generator: ^2.0.1
47:   
48: 
49: flutter:
50:   uses-material-design: true
51: 
52: 
53: flutter_launcher_icons:
54:   image_path: "fftcg_card_icon.png"
55:   android: true
56:   ios: true
</file>

</repository_files>
